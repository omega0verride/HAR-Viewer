<!DOCTYPE html>
<html>
<head>
    <title>HTTP-Waterfall</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'><rect width='200' height='200' rx='40' fill='%23f0f7ff'/><defs><linearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='0%25'><stop offset='0%25' stop-color='%233b82f6'/><stop offset='100%25' stop-color='%2310b981'/></linearGradient></defs><rect x='50' y='50' width='40' height='12' rx='4' fill='url(%23g)'/><rect x='70' y='70' width='50' height='12' rx='4' fill='url(%23g)'/><rect x='85' y='90' width='60' height='12' rx='4' fill='url(%23g)'/><rect x='100' y='110' width='55' height='12' rx='4' fill='url(%23g)'/><rect x='120' y='130' width='30' height='12' rx='4' fill='url(%23g)'/><path d='M55 62 Q 55 142 120 142' stroke='%233b82f6' stroke-width='2' fill='none' stroke-dasharray='4 2' opacity='0.4'/></svg>">
    <style>
        * { box-sizing: border-box; }
        body { font-family: 'Consolas', 'Monaco', 'Courier New', monospace; background: #121212; color: #e0e0e0; margin: 0; padding: 0; }
        
        .app-brand { display: flex; align-items: center; gap: 8px; }
        .app-name { font-size: 16px; font-weight: bold; background: linear-gradient(90deg, #4fc3f7, #7c4dff); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        
        .header-row { display: flex; align-items: center; gap: 15px; flex-wrap: nowrap; overflow-x: auto; }
        
        .file-selector { display: flex; gap: 8px; align-items: center; flex-shrink: 0; }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }
        
        .file-input-wrapper::after {
            content: 'Open';
            background: #3949ab;
            color: #fff;
            border: none;
            padding: 9px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        
        .vertical-separator {
            width: 1px;
            height: 24px;
            background: #444;
            margin: 0 12px;
            display: inline-block;
            vertical-align: middle;
        }

        .btn {
            background: #3949ab; color: #fff; border: none; padding: 6px 12px; 
            border-radius: 4px; cursor: pointer; font-size: 12px; transition: background 0.2s;
            display: inline-block; white-space: nowrap;
        }
        .btn:hover { background: #5c6bc0; }
        .file-name { color: #4fc3f7; font-size: 12px; }

        .bottom-bar {
            background: #1e1e1e;
            border-top: 2px solid #333;
            padding: 8px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            flex-wrap: wrap;
        }
        
        .bottom-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .bottom-right {
            display: flex;
            align-items: center;
        }
        
        .legend-inline {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        .legend-inline .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 11px;
        }
        
        .instructions-inline {
            font-size: 10px;
            color: #4fc3f7;
        }
        
        .zoom-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .zoom-controls input[type="range"] {
            width: 200px;
            cursor: pointer;
        }
        .zoom-btn {
            background: #3949ab;
            color: #fff;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 500;
            transition: background 0.2s;
            min-width: 45px;
        }
        .zoom-btn:hover {
            background: #5c6bc0;
        }
        .zoom-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        .legend { display: flex; gap: 15px; margin-bottom: 10px; padding: 8px; border-bottom: 1px solid #333; flex-wrap: wrap; align-items: center; }
        .legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; }
        .box { width: 10px; height: 10px; border-radius: 2px; flex-shrink: 0; }
        
        .filter-row { display: flex; gap: 14px 0px; padding: 12px 15px 10px 15px; flex-wrap: wrap; align-items: center; }
        .filter-row input, .filter-row select {
            background: #252525; color: #e0e0e0; border: 1px solid #444;
            padding: 5px 8px; border-radius: 3px; font-size: 12px;
        }
        .filter-row input:focus, .filter-row select:focus { outline: none; border-color: #4fc3f7; }
        .filter-row label { font-size: 13px; color: #aaa; }
        .filter-row .btn { font-size: 11px; padding: 4px 8px; }
        
        .filter-group {
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .filter-group label {
            font-size: 12px;
            color: rgb(189, 189, 189);
            position: absolute;
            top: -6px;
            left: 6px;
            z-index: 1;
            background: #2a2a2a;
            padding: 0 4px;
            border-radius: 3px;
        }
        .filter-group input {
            border-radius: 3px;
            padding: 12px 4px 4px 4px;
        }
        .filter-group .duration-inputs {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .filter-group .uri-input-row {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .filter-group .uri-input-row input {
            border-radius: 3px 0 0 3px;
        }
        .filter-group .uri-input-row .regex-toggle {
            border-radius: 0 3px 3px 0;
            margin-left: -1px;
        }
        .filter-row .regex-toggle {
            background: #333;
            color: #666;
            border: 1px solid #444;
            padding: 8px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-family: monospace;
            transition: all 0.2s;
        }
        .filter-row .regex-toggle.active {
            background: #3949ab;
            color: #fff;
            border-color: #5c6bc0;
        }
        .filter-row .regex-toggle:hover {
            border-color: #4fc3f7;
        }
        
        .github-link {
            position: fixed;
            top: 14px;
            right: 10px;
            z-index: 1000;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        .github-link:hover {
            opacity: 1;
        }
        .github-link svg {
            width: 24px;
            height: 24px;
            fill: #e0e0e0;
        }
        
        .main-content { height: 100vh; display: flex; flex-direction: column; overflow: hidden; padding: 0; margin: 0; position: relative; }
        
        #content { display: none; flex-direction: column; flex: 1; min-height: 0; overflow: hidden; }
        #content.active { display: flex; flex: 1; min-height: 0; }
        
        .filter-row { flex-shrink: 0; flex-wrap: wrap; }
        
        .table-container { 
            display: flex; 
            border: 1px solid #333; 
            border-radius: 4px; 
            overflow: hidden; 
            flex: 1;
            min-height: 0;
            position: relative;
        }
        
        .timeline-table { width: auto; border-collapse: separate; border-spacing: 0; min-width: stretch; table-layout: fixed; }
        .timeline-table th {
            background: #252525; padding: 8px 6px; text-align: left;
            font-size: 13px; color: #888; text-transform: uppercase;
            border-bottom: 2px solid #444;
            height: 38px;
            white-space: nowrap;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .timeline-table td {
            padding: 4px 6px; border-bottom: 1px solid #2a2a2a; vertical-align: middle;
            height: 38px;
            max-height: 38px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .timeline-table tbody tr { height: 38px; max-height: 38px; }
        
        .timeline-table th:nth-child(1) { width: 40px; }
        .timeline-table th:nth-child(2) { width: 50px; }
        .timeline-table th:nth-child(3) { width: 110px; }
        .timeline-table th:nth-child(4) { width: 65px; }
        .timeline-table th:nth-child(5) { width: 50px; }
        .timeline-table th:nth-child(6) { width: 55px; }
        .timeline-table th:nth-child(7) { width: 32px; }
        .timeline-table th:nth-child(8) { width: 50px; text-align: center; }
        .timeline-table th:nth-child(9) { width: 32px; }
        .timeline-table th:nth-child(10) { width: 32px; }
        .timeline-table th:nth-child(11) { width: 38px; }
        .timeline-table th:nth-child(12) { width: auto; }

        .request-row { cursor: pointer; transition: background 0.15s; user-select: none; }
        .request-row.hover, .timeline-column.hover { background: #252525; }
        .timeline-bar.hover { filter: brightness(1.2); }
        .request-row.selected-start, .timeline-column.selected-start { background: rgba(79, 195, 247, 0.2); }
        .request-row.selected-end, .timeline-column.selected-end { background: rgba(240, 98, 146, 0.2); }
        .request-row.selected, .timeline-column.selected { background: rgba(79, 195, 247, 0.15); }
        .request-row.highlight, .timeline-column.highlight { background: rgba(255, 235, 59, 0.15); }

        .request-row td:nth-child(1) { text-align: center; width: 40px; font-size: 11px; color: #888; }
        .request-row td:nth-child(2) { text-align: center; }
        .request-row td:nth-child(3) { text-align: center; }
        .request-row td:nth-child(5) { font-size: 11px; }
        .request-row td:nth-child(6) { text-align: center; }
        .request-row td:nth-child(7) { text-align: center; }
        .request-row td:nth-child(8) { text-align: center; font-size: 11px; }
        .request-row td:nth-child(9) { text-align: center; font-size: 11px; }
        .request-row td:nth-child(10) { text-align: center; font-size: 11px; }
        .request-row td:nth-child(11) { text-align: center; }
        .request-row td:nth-child(12) { text-align: left; }
        
        /* Status colors based on HTTP status code ranges */
        .status-1xx { color: #80deea; }  /* Informational - cyan */
        .status-2xx { color: #81c784; }  /* Success - green */
        .status-3xx { color: #ffb74d; }  /* Redirection - orange */
        .status-4xx { color: #ff8a65; }  /* Client Error - deep orange */
        .status-5xx { color: #e57373; }  /* Server Error - red */
        .status-0xx { color: #9e9e9e; }  /* 0, negative, or invalid - gray */
        .status-6xx { color: #ce93d8; }  /* >= 600 outliers - purple */
        
        .status-badge {
            display: inline-block; padding: 2px 8px; border-radius: 3px;
            font-size: 12px; font-weight: bold; font-family: monospace;
        }
        .status-badge.status-1xx { background: #006064; color: #fff; }
        .status-badge.status-2xx { background: #1b5e20; color: #fff; }
        .status-badge.status-3xx { background: #e65100; color: #fff; }
        .status-badge.status-4xx { background: #bf360c; color: #fff; }
        .status-badge.status-5xx { background: #b71c1c; color: #fff; }
        .status-badge.status-0xx { background: #424242; color: #fff; }
        .status-badge.status-6xx { background: #4a148c; color: #fff; }
        
        .type-badge {
            display: inline-block; padding: 2px 6px; border-radius: 3px;
            font-size: 10px; font-weight: bold; font-family: monospace;
            background: #333; color: #aaa;
        }
        .type-badge.type-json { background: #1e3a5f; color: #4fc3f7; }
        .type-badge.type-xml { background: #3e2723; color: #ffab91; }
        .type-badge.type-html { background: #3e2723; color: #ffab91; }
        .type-badge.type-text { background: #263238; color: #b0bec5; }
        .type-badge.type-img { background: #1b5e20; color: #81c784; }
        .type-badge.type-js { background: #f57f17; color: #fff; }
        .type-badge.type-css { background: #1565c0; color: #fff; }
        .type-badge.type-font { background: #4a148c; color: #e1bee7; }
        .type-badge.type-pdf { background: #b71c1c; color: #ff8a80; }
        .type-badge.type-arch { background: #f57c00; color: #ffe0b2; }
        .type-badge.type-bin { background: #424242; color: #e0e0e0; }
        
        .duration-text { font-family: monospace; font-size: 12px; }
        
        .endpoint-cell { 
            font-size: 13px; white-space: nowrap; overflow: hidden; 
            text-overflow: ellipsis; position: relative;
        }
        .endpoint-method { 
            display: inline-block; padding: 1px 6px; border-radius: 3px;
            font-size: 10px; font-weight: bold; margin-right: 6px; background: #333;
        }
        .endpoint-method.get { background: #1565c0; }
        .endpoint-method.post { background: #2e7d32; }
        .endpoint-method.put { background: #f57c00; }
        .endpoint-method.delete { background: #c62828; }
        .endpoint-method.patch { background: #7b1fa2; }
        
        .uri-tooltip { 
            display: none; position: fixed; background: #000; color: #fff;
            padding: 10px; border-radius: 4px; font-size: 12px; z-index: 200;
            max-width: 500px; word-break: break-all;
            border: 1px solid #444; box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .timeline-column {
            position: relative; height: 38px;
            border-bottom: 1px solid #2a2a2a;
            transition: background 0.15s;
            box-sizing: border-box;
        }
        
        .timeline-bar {
            position: absolute; height: 24px; top: 7px; border-radius: 4px;
            cursor: pointer; transition: transform 0.1s, box-shadow 0.1s;
            display: flex; align-items: center; padding: 0 8px 0 4px;
            font-size: 11px; color: #fff; white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .timeline-bar:hover { 
            transform: scaleY(1.15); z-index: 10; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        /* Timeline bar colors based on HTTP status code ranges */
        .timeline-bar.status-1xx { background: linear-gradient(90deg, #00838f, #00acc1); }
        .timeline-bar.status-2xx { background: linear-gradient(90deg, #2e7d32, #66bb6a); }
        .timeline-bar.status-3xx { background: linear-gradient(90deg, #ef6c00, #ffa726); }
        .timeline-bar.status-4xx { background: linear-gradient(90deg, #d84315, #ff7043); }
        .timeline-bar.status-5xx { background: linear-gradient(90deg, #c62828, #ef5350); }
        .timeline-bar.status-0xx { background: linear-gradient(90deg, #424242, #757575); }
        .timeline-bar.status-6xx { background: linear-gradient(90deg, #6a1b9a, #ab47bc); }
        .timeline-bar.selected-start { 
            border: 2px solid #4fc3f7 !important; 
            box-shadow: 0 0 10px #4fc3f7; 
        }
        .timeline-bar.selected-end { 
            border: 2px solid #f06292 !important; 
            box-shadow: 0 0 10px #f06292; 
        }
        .timeline-bar.selected { 
            border: 2px solid #4fc3f7 !important; 
            box-shadow: 0 0 6px #4fc3f7; 
        }
        .timeline-bar.highlight { 
            border: 2px solid #ffeb3b !important; 
            box-shadow: 0 0 8px #ffeb3b; 
        }
        .timeline-bar.exaggerated {
            opacity: 0.6;
            border-style: dashed;
        }
        
        .thread-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            padding: 0 6px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            margin-right: 4px;
            color: #fff;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }
        
        .timeline-header {
            position: sticky; top: 0; height: 38px; background: #1a1a1a;
            border-bottom: 2px solid #444;
            box-sizing: border-box;
            z-index: 10;
        }
        .timeline-header-label { 
            position: absolute; font-size: 10px; color: #666;
            transform: translateX(-50%);
        }
        .timeline-header-tick {
            position: absolute; bottom: 0; width: 1px; height: 6px;
            background: #444;
        }
        
        .table-container { 
            display: flex; 
            border: 1px solid #333; 
            border-radius: 4px; 
            overflow: hidden;
            min-height: 200px;
            position: relative;
        }
        .details-section {
            flex-shrink: 0;
            overflow-x: auto;
            overflow-y: auto;
            width: 50%;
            min-width: 200px;
            max-width: 80vw;
        }
        .details-section::-webkit-scrollbar { width: 8px; height: 8px; }
        .details-section::-webkit-scrollbar-track { background: #1a1a1a; }
        .details-section::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        
        .resizer {
            width: 6px;
            background: #333;
            cursor: col-resize;
            flex-shrink: 0;
            position: relative;
            transition: background 0.2s;
        }
        .resizer:hover, .resizer.dragging {
            background: #4fc3f7;
        }
        .resizer::after {
            content: '';
            position: absolute;
            left: 1px;
            right: 1px;
            top: 50%;
            transform: translateY(-50%);
            height: 30px;
            background: linear-gradient(to bottom, transparent, #666, transparent);
            border-radius: 2px;
        }
        
        .timeline-section { 
            flex: 1; 
            overflow: auto; 
            background: #181818;
            position: relative;
            min-width: 300px;
        }
        .timeline-section::-webkit-scrollbar { width: 8px; height: 8px; }
        .timeline-section::-webkit-scrollbar-track { background: #1a1a1a; }
        .timeline-section::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        
        .timeline-scroll { 
            min-width: 100%; 
            background: linear-gradient(90deg, #121212 0%, #1a1a2e 50%, #121212 100%);
            position: relative;
        }
        
        .cursor-line {
            position: fixed;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(79, 195, 247, 0.7);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .cursor-time {
            position: fixed;
            background: #4fc3f7;
            color: #000;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 3px;
            pointer-events: none;
            z-index: 1001;
            white-space: nowrap;
            font-weight: bold;
            display: none;
        }
        
        .measure-marker {
            position: absolute;
            top: 0;
            width: 2px;
            z-index: 60;
            pointer-events: none;
        }
        .measure-marker.start {
            background: #4fc3f7;
        }
        .measure-marker.end {
            background: #f06292;
        }
        .measure-marker-label {
            position: absolute;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            white-space: nowrap;
            transform: translateX(-50%);
            z-index: 61;
            top: -18px;
        }
        .measure-marker-label.start {
            background: #4fc3f7;
            color: #000;
        }
        .measure-marker-label.end {
            background: #f06292;
            color: #000;
        }
        
        .error { background: #b71c1c; color: #fff; padding: 15px; border-radius: 6px; margin-bottom: 20px; }

        .empty-state {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            justify-content: center;
            min-height: 100vh;
            padding: 40px;
            text-align: left;
            gap: 60px;
            flex-wrap: wrap;
            overflow-y: auto;
        }
        .empty-state.hidden { display: none; }

        .drop-zone {
            border: 3px dashed #444;
            border-radius: 12px;
            padding: 60px 80px;
            background: #1a1a1a;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .drop-zone:hover {
            border-color: #4fc3f7;
            background: #1e2a3a;
        }
        .drop-zone.drag-over {
            border-color: #4fc3f7;
            background: #1e3a4a;
            transform: scale(1.02);
        }

        .drop-zone-icon {
            font-size: 48px;
            margin-bottom: 20px;
            color: #666;
        }
        .drop-zone:hover .drop-zone-icon,
        .drop-zone.drag-over .drop-zone-icon {
            color: #4fc3f7;
        }

        .drop-zone-text {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 10px;
        }
        .drop-zone-subtext {
            font-size: 13px;
            color: #666;
        }

        .select-file-btn {
            background: #3949ab;
            color: #fff;
            border: none;
            padding: 12px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            margin-top: 20px;
        }
        .select-file-btn:hover {
            background: #5c6bc0;
            transform: translateY(-1px);
            cursor: pointer;
        }

        .instructions {
            max-width: 600px;
            margin-top: 40px;
            text-align: left;
        }
        .instructions-title {
            font-size: 14px;
            color: #888;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .instructions-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .instructions-list li {
            padding: 8px 0;
            color: #aaa;
            font-size: 13px;
            border-bottom: 1px solid #2a2a2a;
        }
        .instructions-list li:last-child {
            border-bottom: none;
        }
        .instructions-list li::before {
            content: "‚Ä∫";
            color: #4fc3f7;
            margin-right: 10px;
            font-weight: bold;
        }
        .code-block {
            background: #252525;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 12px;
            color: #4fc3f7;
        }
        
        .details-row { display: none; background: #1a1a1a; }
        .details-row.open { display: table-row; }
        .details-row td { padding: 15px 20px; border-bottom: 2px solid #333; }
        .details-grid { display: grid; grid-template-columns: 120px 1fr; gap: 8px; }
        .details-label { color: #888; font-size: 12px; }
        .details-value { font-size: 13px; word-break: break-all; }
        
        .action-btn { 
            background: #333; color: #4fc3f7; border: none; padding: 4px 6px; 
            border-radius: 3px; cursor: pointer; font-size: 11px; text-decoration: none;
            display: inline-block;
        }
        .action-btn:hover { background: #444; }
        .action-btn.link { background: transparent; color: #4fc3f7; padding: 2px 4px; }
        .action-btn.link:hover { text-decoration: underline; }

        .measure-panel {
            display: none;
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            gap: 12px;
            align-items: center;
            padding: 8px 16px;
            background: #1a237e;
            border-radius: 4px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            height: 50px;
        }
        .measure-panel.active { display: flex; }
        .measure-item { display: flex; align-items: center; gap: 4px; }
        .measure-value { font-size: 13px; font-weight: bold; color: #4fc3f7; font-family: monospace; }
        .measure-label { font-size: 11px; color: #888; }
        .measure-clear { background: #3949ab; border: none; color: #fff; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px; }

        .stats-popup {
            display: none;
            position: fixed;
            bottom: 50px;
            right: 15px;
            background: #1e1e1e;
            border-radius: 8px;
            max-width: 450px;
            max-height: 50vh;
            overflow: auto;
            padding: 15px;
            z-index: 2000;
            box-shadow: 0 -8px 24px rgba(0,0,0,0.6);
            border: 1px solid #333;
        }
        .stats-popup.active { display: block; }
        .stats-title { font-size: 14px; font-weight: bold; margin-bottom: 12px; color: #4fc3f7; }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .stats-item {
            background: #252525;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }
        .stats-item-label { font-size: 12px; color: #aaa; margin-bottom: 3px; }
        .stats-item-value { font-size: 15px; font-weight: bold; color: #4fc3f7; font-family: monospace; }
        .stats-item-value.clickable:hover { color: #80deea; text-decoration: underline; }

        .headers-modal {
            display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.8); z-index: 2000; align-items: center; justify-content: center;
        }
        .headers-modal.active { display: flex; }
        .headers-content {
            background: #1e1e1e; border-radius: 8px; max-width: 700px; max-height: 80vh;
            overflow: auto; padding: 20px; position: relative;
        }
        .headers-close {
            position: absolute; top: 10px; right: 10px; background: #333; border: none;
            color: #fff; width: 28px; height: 28px; border-radius: 50%; cursor: pointer;
            font-size: 16px;
        }
        .headers-close:hover { background: #555; }
        .headers-title { font-size: 14px; font-weight: bold; margin-bottom: 15px; color: #4fc3f7; }
        .headers-section { margin-bottom: 15px; }
        .headers-section-title { font-size: 12px; color: #888; margin-bottom: 8px; text-transform: uppercase; display: flex; justify-content: space-between; align-items: center; }
        .headers-copy-btn { background: #333; border: none; color: #aaa; padding: 2px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; }
        .headers-copy-btn:hover { background: #444; color: #fff; }
        .headers-list { font-family: monospace; font-size: 11px; }
        .header-row { display: flex; gap: 10px; padding: 4px 0; border-bottom: 1px solid #2a2a2a; align-items: flex-start; }
        .header-key { color: #4fc3f7; min-width: 150px; max-width: 150px; word-break: break-word; flex-shrink: 0; }
        .header-value { color: #e0e0e0; word-break: break-all; flex: 1; min-width: 0; }

        .detail-panel {
            position: fixed; top: 0; right: -500px; width: 480px; height: 100vh;
            background: #1e1e1e; z-index: 1500; transition: right 0.25s ease;
            box-shadow: -4px 0 20px rgba(0,0,0,0.5); overflow-y: auto;
        }
        .detail-panel.active { right: 0; }
        
        #bodyModal { right: -800px; width: 700px; }
        #bodyModal.active { right: 0; }
        
        .body-no-wrap { white-space: pre; overflow-x: auto; display: block; }
        .body-wrap { white-space: pre-wrap; word-break: break-all; display: block; }
        .detail-panel-header {
            position: sticky; top: 0; background: #252525; padding: 15px 20px;
            border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;
            z-index: 15;
        }
        .detail-panel-title { font-size: 15px; font-weight: bold; color: #4fc3f7; display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
        .detail-panel-title > span:first-child { flex-shrink: 0; }
        .detail-panel-title .id-badge { font-size: 12px; background: #333; color: #fff; padding: 3px 8px; border-radius: 4px; font-weight: bold; }
        .detail-panel-subtitle { font-size: 11px; color: #888; margin-top: 4px; width: 100%; display: flex; flex-wrap: wrap; align-items: center; gap: 6px; }
        .detail-panel-close {
            background: #333; border: none; color: #fff; width: 28px; height: 28px;
            border-radius: 50%; cursor: pointer; font-size: 18px;
        }
        .detail-panel-close:hover { background: #555; }
        .format-btn { padding: 4px 10px; font-size: 11px; background: #333; color: #aaa; border: none; border-radius: 4px; cursor: pointer; }
        .format-btn:hover { background: #444; color: #fff; }
        .format-btn.active { background: #4fc3f7; color: #000; }
        .detail-panel-content { padding: 20px; position: relative; z-index: 10; }
        .detail-section { margin-bottom: 20px; }
        .detail-section-title {
            font-size: 14px; color: #ccc; font-weight: bold; margin: 16px 0 12px 0; text-transform: uppercase;
            display: flex; justify-content: space-between; align-items: center;
        }
        .detail-section-title { display: flex; align-items: center; justify-content: space-between; }
        .detail-section.collapsed .collapsible-content { display: none; }
        .detail-section.collapsed .detail-copy-btn { display: none; }
        .detail-section.collapsed .collapse-icon { transform: rotate(-90deg); }
        .collapsible-title { cursor: pointer; display: flex; align-items: center; gap: 8px; flex: 1; }
        .collapsible-title:hover { color: #aaa; }
        .collapsible-content { clear: both; word-break: break-word; overflow-wrap: anywhere; }
        .detail-title-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        .detail-copy-btn {
            background: #3949ab; border: none; color: #fff; padding: 3px 8px;
            border-radius: 3px; cursor: pointer; font-size: 10px; text-transform: none;
        }
        .detail-copy-btn:hover { background: #4f63d7; }
        .detail-row { display: flex; padding: 6px 0; border-bottom: 1px solid #2a2a2a; }
        .detail-row[style*="flex-direction: column"] { align-items: flex-start; }
        .detail-method { font-size: 12px; }
        .detail-uri { text-decoration: none; font-size: 11px; word-break: break-all; }
        .detail-uri:hover { text-decoration: underline; }
        .detail-label { color: #888; min-width: 100px; font-size: 11px; }
        .detail-value { color: #e0e0e0; font-size: 11px; word-break: break-all; flex: 1; }
        .detail-value.method-GET { color: #4fc3f7; }
        .detail-value.method-POST { color: #81c784; }
        .detail-value.method-PUT { color: #ffb74d; }
        .detail-value.method-DELETE { color: #e57373; }
        .detail-value.method-PATCH { color: #ba68c8; }
        .detail-value.status-2xx { color: #81c784; }
        .detail-value.status-3xx { color: #ffb74d; }
        .detail-value.status-4xx { color: #e57373; }
        .detail-value.status-5xx { color: #f06292; }
        .detail-empty { color: #666; font-style: italic; font-size: 12px; }

        .detail-backdrop {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            z-index: 1499;
            display: none;
        }
        .detail-backdrop.active { display: block; }
    
    </style>
</head>
<body>

    <a href="https://github.com/omega0verride/HTTP-Waterfall" target="_blank" class="github-link" title="HTTP-Waterfall on GitHub">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
        </svg>
    </a>

    <div class="main-content">
        <div id="errorBox" class="error" style="display: none;"></div>
        
        <div id="content">
            <div class="filter-row">
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".json,.har">
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>Method</label>
                    <input type="text" id="filterMethod" placeholder="GET,POST,PUT" oninput="applyFilter()" style="width: 100px;" title="Filter by HTTP methods. Multiple: GET,POST,PUT">
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>URI</label>
                    <div class="uri-input-row">
                        <input type="text" id="filterText" placeholder="Search or regex..." oninput="applyFilter()" style="width: 220px;">
                        <button type="button" id="regexToggle" class="regex-toggle" onclick="toggleRegexMode()" title="Toggle regex mode">.*</button>
                    </div>
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>Status</label>
                    <input type="text" id="filterStatus" placeholder="e.g. 200, -1, 0, 200-299" oninput="applyFilter()" style="width: 140px;" title="Filter by status codes. Single: 200, -1. Multiple: 200,404. Range: 200-299, -10--1">
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>Thread</label>
                    <input type="text" id="filterThread" placeholder="1,2,3" oninput="applyFilter()" style="width: 80px;" title="Filter by thread IDs. Multiple: 1,2,3">
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>Duration</label>
                    <div class="duration-inputs">
                        <input type="text" id="filterMinDuration" placeholder="min" oninput="applyFilter()" style="width: 70px;" title="Min duration. Examples: 1h, 30m, 1m 30s">
                        <span style="color:#888">-</span>
                        <input type="text" id="filterMaxDuration" placeholder="max" oninput="applyFilter()" style="width: 70px;" title="Max duration. Examples: 1h, 30m, 1m 30s">
                    </div>
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>Type</label>
                    <input type="text" id="filterType" placeholder="JSON,HTML,IMG" oninput="applyFilter()" style="width: 80px;" title="Filter by response type. Multiple: JSON,HTML,IMG">
                </div>
                <div class="vertical-separator"></div>
                <div class="filter-group">
                    <label>Base URI</label>
                    <input type="text" id="filterBaseUri" placeholder="e.g. http://localhost:3000/" oninput="applyFilter()" style="width: 150px;" title="Strip prefix from URIs in display only">
                </div>
                <div class="vertical-separator" style="display: none;"></div>
                <button class="btn" id="clearFiltersBtn" onclick="clearFilters()" style="padding: 6px 12px; font-size: 12px; display: none;">‚úï Clear</button>
            </div>
            
            <div class="table-container" id="timeline"></div>
            
            <div class="bottom-bar">
                <div class="bottom-left">
                    <div class="legend-inline">
                        <span class="legend-item"><div class="box" style="background: #00acc1;"></div> 1xx</span>
                        <span class="legend-item"><div class="box" style="background: #66bb6a;"></div> 2xx</span>
                        <span class="legend-item"><div class="box" style="background: #ffa726;"></div> 3xx</span>
                        <span class="legend-item"><div class="box" style="background: #ff7043;"></div> 4xx</span>
                        <span class="legend-item"><div class="box" style="background: #ef5350;"></div> 5xx</span>
                        <span class="legend-item"><div class="box" style="background: #757575;"></div> 0/-</span>
                    </div>
                    <div class="instructions-inline">Click=select | Ctrl+Click=multi | Shift+Click=range | Ctrl+A=all | ID click=details | Shift+Scroll=horizontal | +/-=zoom</div>
                </div>
                <div class="bottom-right">
                    <div class="zoom-controls">
                        <button class="btn" onclick="zoomOut()" style="padding: 4px 10px; font-size: 13px; font-weight: bold;">‚àí</button>
                        <input type="range" id="zoomSlider" min="0" max="100" value="40" oninput="handleZoomChange()">
                        <button class="btn" onclick="zoomIn()" style="padding: 4px 10px; font-size: 13px; font-weight: bold;">+</button>
                        <span id="zoomValue" style="font-size: 11px; color: #888; min-width: 50px;">20k</span>
                        <button class="zoom-btn" id="fitBtn" onclick="zoomToFit()" title="Fit all requests to viewport">‚õ∂ Fit</button>
                        <button class="zoom-btn" id="selBtn" onclick="zoomToSelection()" title="Zoom to selected time range">üîç Zoom Selection</button>

                    </div>
                    <div class="vertical-separator"></div>
                    <button class="btn" id="statsButton" style="display: none; margin-right: 10px;">üìä Stats</button>
                </div>
            </div>
        </div>
        
        <div id="empty" class="empty-state">
            <div style="display: flex; flex-direction: column; align-items: center; margin-top: 40px;">
                <div style="display: flex; flex-direction: row;">
                    <svg width="100" height="100" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" style="margin-bottom: 15px;">
                        <rect width="200" height="200" rx="40" fill="#f0f7ff"/>
                        <defs>
                            <linearGradient id="barGradient3" x1="0%" y1="0%" x2="100%" y2="0%">
                                <stop offset="0%" style="stop-color:#3b82f6"/>
                                <stop offset="100%" style="stop-color:#10b981"/>
                            </linearGradient>
                        </defs>
                        <rect x="50" y="50" width="40" height="12" rx="4" fill="url(#barGradient3)"/>
                        <rect x="70" y="70" width="50" height="12" rx="4" fill="url(#barGradient3)"/>
                        <rect x="85" y="90" width="60" height="12" rx="4" fill="url(#barGradient3)"/>
                        <rect x="100" y="110" width="55" height="12" rx="4" fill="url(#barGradient3)"/>
                        <rect x="120" y="130" width="30" height="12" rx="4" fill="url(#barGradient3)"/>
                        <path d="M55 62 Q 55 142 120 142" stroke="#3b82f6" stroke-width="2" fill="none" stroke-dasharray="4 2" opacity="0.4"/>
                        <text x="50%" y="175" text-anchor="middle" font-family="sans-serif" font-weight="bold" font-size="16" fill="#1e293b">HTTP WATERFALL</text>
                    </svg>
                    <div style="text-align: left; margin-left: 20px; margin-bottom: 20px; width: 280px;">
                        <div style="font-size: 28px; font-weight: bold; color: #4fc3f7; margin-bottom: 8px;">HTTP-Waterfall</div>
                        <div style="font-size: 14px; color: #888;">Visualize and analyze HTTP requests from HAR archives or our custom JSON format.</div>
                    </div>
                </div>
                <div class="drop-zone" id="dropZone">
                    <div class="drop-zone-icon">üìÅ</div>
                    <div class="drop-zone-text">Drop HTTP requests file here (HAR or JSON)</div>
                    <div class="drop-zone-subtext">or click to browse</div>
                    <input type="file" id="dropZoneFileInput" accept=".json,.har" style="display: none; cursor: pointer;">
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="select-file-btn" onclick="document.getElementById('dropZoneFileInput').click()">Select File</button>
                        <button class="select-file-btn" onclick="downloadSampleJson()" style="background: #2d5a3d;">Download Sample</button>
                    </div>
                </div>
            </div>

            <div class="instructions">
                <div class="instructions-title">Supported Formats</div>
                <p style="color:#888;font-size:12px;margin-bottom:15px;">
                    Upload a HAR (HTTP Archive) file or our custom format JSON file.
                </p>
                
                <div style="margin-bottom: 20px;">


                    <div style="margin-bottom: 20px;">
                        <div style="color:#aaa;font-size:16px;margin-bottom:5px;">1. HAR format:
                            <a href="http://www.softwareishard.com/blog/har-12-spec/" target="_blank" rel="noopener" style="color:#4fc3f7;font-size:11px;margin-left:10px;">HAR 1.2 spec</a>
                            <a href="https://toolbox.googleapps.com/apps/har_analyzer/" target="_blank" style="color:#4fc3f7;font-size:11px;margin-left:10px;">Analyzer</a>
                        </div>
                    </div>
                    <div style="color:#aaa;font-size:16px;margin-bottom:5px;">2. Custom JSON format:
                        <a href="https://github.com/omega0verride/HTTP-waterfall?tab=readme-ov-file#2-custom-json-format" target="_blank" rel="noopener" style="color:#4fc3f7;font-size:11px;margin-left:10px;">Spec on GitHub</a>
                        <a href="https://github.com/omega0verride/HTTP-waterfall/tree/main/samples/" target="_blank" rel="noopener" style="color:#4fc3f7;font-size:11px;margin-left:10px;">Samples</a>
                    </div>
                    <div style="color:#666;font-size:11px;margin-top:6px;">
                        <p>The custom JSON format is designed to be lightweight and easy to generate and parse, with support for both inline content and external file references.</p>
                        <p>It is simplier than HAR allowing for easier generation and integration with non-standard tools that do not export HAR (you do not have to implement the full HAR spec.).</p>
                    </div>
                    <div style="color:#aaa;font-size:16px;margin-bottom:5px;"></div>
                    <pre style="background:#1e1e1e;padding:12px;border-radius:6px;overflow-x:auto;font-size:11px;color:#ccc;">[
  {
    "id": 1,
    "uri": "http://localhost:3000/api/users",
    "method": "GET",
    "statusCode": 200,
    "statusMessage": "OK",
    "startRequestTimestamp": 1704067200000,
    "beginResponseTimestamp": 1704067200150,
    "endResponseTimestamp": 1704067200200,
    "threadId": "main",
    "requestHeaders": "Content-Type: application/json\nAuthorization: Bearer ...",
    "responseHeaders": "Content-Type: application/json\nContent-Length: 512",
    "requestBodyChunks": ["{ \"name\": \"Alice\" }"],
    "responseBodyChunks": ["{ \"id\": 1, \"name\": \"Alice\" }"],
    "requestBodyPath": "req_body_1.json",
    "responseBodyPath": "res_body_1.json"
  },
  ...
]</pre>
                    <div style="color:#666;font-size:11px;margin-top:6px;">
                        <strong style="color:#888;">Note:</strong>
                        <strong>requestBodyPath</strong>/<strong>responseBodyPath</strong> and <strong>requestBodyChunks[]</strong>/<strong>responseBodyChunks[]</strong> are interchangeable.
                        Chunks contain the actual content inline; paths are links to external files (to save memory).
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="detail-backdrop" id="detailBackdrop" onclick="closeDetailPanel()"></div>

    <div class="detail-panel" id="detailPanel">
        <div class="detail-panel-header">
            <div style="flex: 1; min-width: 0;">
                <span class="detail-panel-title">
                <span class="detail-panel-title">
                    <span>Request #<span id="detailOrdinal"></span></span>
                    <span class="id-badge">ID: <span id="detailId"></span></span>
                </span>
                <div class="detail-panel-subtitle">
                    <span style="font-size:11px;background:#333;color:#aaa;padding:2px 6px;border-radius:3px;margin-right:8px;">Thread</span>
                    <span class="thread-badge" id="detailThreadBadge" style="font-size:10px;padding:2px 6px;background:#444;word-break:break-all;max-width:200px;"></span>
                </div>
                <div class="detail-panel-subtitle" id="detailTimestamp"></div>
            </div>
            <button class="detail-panel-close" onclick="closeDetailPanel()">√ó</button>
        </div>
        <div class="detail-panel-content" id="detailPanelContent"></div>
    </div>

    <div class="headers-modal" id="headersModal" onclick="closeHeadersModal(event)">
        <div class="headers-content" onclick="event.stopPropagation()">
            <button class="headers-close" onclick="closeHeadersModal()">√ó</button>
            <div class="headers-title" id="headersTitle">Headers</div>
            <div class="headers-section">
                <div class="headers-section-title">
                    Request Headers
                    <button class="headers-copy-btn" onclick="copyHeaders('request', this)">Copy</button>
                </div>
                <div class="headers-list" id="requestHeadersList"></div>
            </div>
            <div class="headers-section">
                <div class="headers-section-title">
                    Response Headers
                    <button class="headers-copy-btn" onclick="copyHeaders('response', this)">Copy</button>
                </div>
                <div class="headers-list" id="responseHeadersList"></div>
            </div>
        </div>
    </div>

    <div class="detail-backdrop" id="bodyBackdrop" onclick="closeBodyModal();"></div>
    <div class="detail-panel" id="bodyModal">
        <div class="detail-panel-header">
            <div style="flex: 1; min-width: 0;">
                <span class="detail-panel-title" id="bodyModalTitle">Body</span>
                <button class="detail-panel-close" onclick="closeBodyModal()" style="position:absolute;top:10px;right:10px;">√ó</button>
            </div>
        </div>
        <div style="background:#252525;padding:8px 15px;display:flex;gap:8px;align-items:center;flex-wrap:wrap;border-bottom:1px solid #333;">
            <button class="btn format-btn active" data-format="raw" onclick="setBodyFormat('raw')">RAW</button>
            <button class="btn format-btn" data-format="json" onclick="setBodyFormat('json')">JSON</button>
            <button class="btn format-btn" data-format="xml" onclick="setBodyFormat('xml')">XML</button>
            <button class="btn format-btn" data-format="html" onclick="setBodyFormat('html')">HTML</button>
            <button class="btn format-btn" data-format="image" onclick="setBodyFormat('image')">Image</button>
            <button class="btn format-btn" data-format="hex" onclick="setBodyFormat('hex')">HEX</button>
            <span style="color:#666;font-size:11px;">|</span>
            <span id="bodySizeIndicator" style="color:#888;font-size:11px;">--</span>
            <button class="btn" onclick="copyBodyContent()" style="background:#333;color:#aaa;font-size:11px;padding:4px 10px;border:none;border-radius:4px;cursor:pointer;">Copy</button>
            <label style="display:flex;align-items:center;gap:4px;cursor:pointer;color:#aaa;font-size:11px;">
                <input type="checkbox" id="wrapToggle" onchange="toggleBodyWrap()">
                Wrap
            </label>
        </div>
        <div class="detail-panel-content" id="bodyModalContent" style="padding: 15px;">
            <textarea id="bodyContent" class="body-no-wrap" tabindex="0" spellcheck="false" style="background:#1e1e1e;padding:15px;border-radius:6px;overflow:auto;height:calc(100vh - 160px);font-size:12px;color:#ccc;margin:0;display:block;width:100%;border:1px solid #444;resize:none;font-family:monospace;"></textarea>
        </div>
    </div>

    <div class="stats-popup" id="statsPopup">
        <div class="stats-title">Statistics</div>
        <div class="stats-grid">
            <div class="stats-item">
                <div class="stats-item-label">üìä Total Requests</div>
                <div class="stats-item-value" id="statsTotalRequests">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">‚è±Ô∏è Time Span</div>
                <div class="stats-item-value" id="statsTotalTime">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">üê¢ Top Delayed Request</div>
                <div class="stats-item-value clickable" id="statsTopDelayed" style="cursor: pointer;">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">‚ö° Avg Total Duration</div>
                <div class="stats-item-value" id="statsAvgDuration">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">üì§ Avg Request Time</div>
                <div class="stats-item-value" id="statsAvgRequestTime">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">üì• Avg Response Time</div>
                <div class="stats-item-value" id="statsAvgResponseTime">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">üì§ Total Request Time</div>
                <div class="stats-item-value" id="statsTotalRequestTime">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">üì• Total Response Time</div>
                <div class="stats-item-value" id="statsTotalResponseTime">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">‚úÖ Successful (2xx)</div>
                <div class="stats-item-value" style="color: #81c784;" id="statsSuccessCount">--</div>
            </div>
            <div class="stats-item">
                <div class="stats-item-label">‚ùå Failed (4xx/5xx)</div>
                <div class="stats-item-value" style="color: #e57373;" id="statsFailedCount">--</div>
            </div>
        </div>
    </div>

    <div class="measure-panel" id="measurePanel">
        <div class="measure-item"><span class="measure-label">Total:</span><span class="measure-value" id="measureTotal">--</span></div>
        <div class="measure-item"><span class="measure-label">Œî:</span><span class="measure-value" id="measureTime">--</span></div>
        <div class="measure-item"><span class="measure-label">From:</span><span class="measure-value" id="measureStartId">--</span></div>
        <div class="measure-item"><span class="measure-label">To:</span><span class="measure-value" id="measureEndId">--</span></div>
        <button class="measure-clear" onclick="clearMeasure()">‚úï</button>
    </div>

    <script>
        let selectionState = null;
        let startBar = null;
        let endBar = null;
        let allRequests = [];
        let filteredRequests = [];
        let timeRange = { min: 0, max: 0 };
        let threadColors = {};
        let startMarker = null;
        let endMarker = null;
        let startTime = null;
        let endTime = null;
        let requestsDataPath = null;
        let jsonFileHandle = null;
        
        const THREAD_COLORS = [
            '#e53935', '#1e88e5', '#43a047', '#fb8c00', '#8e24aa',
            '#00acc1', '#ffb300', '#6d4c41', '#546e7a', '#d81b60',
            '#5e35b1', '#039be5', '#7cb342', '#c0ca33', '#f4511e'
        ];
        
        function getThreadColor(threadId) {
            if (!threadColors[threadId]) {
                const colorIndex = Object.keys(threadColors).length % THREAD_COLORS.length;
                threadColors[threadId] = THREAD_COLORS[colorIndex];
            }
            return threadColors[threadId];
        }
        
        function getTypeFromContentType(contentType) {
            if (!contentType) return '';
            const ct = contentType.toLowerCase();
            if (ct.includes('json')) return 'JSON';
            if (ct.includes('image/')) return 'IMG';
            if (ct.includes('xml') && !ct.includes('image/')) return 'XML';
            if (ct.includes('html')) return 'HTML';
            if (ct.includes('javascript') || ct.includes('application/x-javascript')) return 'JS';
            if (ct.includes('text/css')) return 'CSS';
            if (ct.includes('font')) return 'FONT';
            if (ct.includes('pdf')) return 'PDF';
            if (ct.includes('zip') || ct.includes('gzip') || ct.includes('tar') || ct.includes('rar')) return 'ARCH';
            if (ct.includes('octet-stream') || ct.includes('binary')) return 'BIN';
            if (ct.includes('text/')) return 'TEXT';
            return ct.split(';')[0].split('/').pop().substring(0, 8);
        }
        
        document.getElementById('fileInput').addEventListener('change', handleFileSelect);
        
        window.addEventListener('pageshow', function(event) {
            const fileInput = document.getElementById('fileInput');
            const dropZoneFileInput = document.getElementById('dropZoneFileInput');
            if (fileInput) fileInput.value = '';
            if (dropZoneFileInput) dropZoneFileInput.value = '';
        });
        
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Check if it's a HAR file
                    if (data.log && data.log.entries) {
                        const converted = convertHarToRequests(data);
                        processData(converted);
                    } else {
                        processData(data);
                    }
                } catch (err) {
                    showError('Failed to parse file: ' + err.message);
                }
                // Clear input so same file can be re-selected
                event.target.value = '';
            };
            reader.onerror = function() {
                showError('Failed to read file');
                event.target.value = '';
            };
            reader.readAsText(file);
        }
        
        function convertHarToRequests(har) {
            const entries = har.log?.entries || [];
            let id = 1;
            
            const requests = entries.map(entry => {
                const req = entry.request || {};
                const res = entry.response || {};
                const startTime = entry.startedDateTime ? new Date(entry.startedDateTime).getTime() : 0;
                const time = entry.time || 0;
                
                // Extract headers from HAR format
                const requestHeaders = {};
                (req.headers || []).forEach(h => {
                    requestHeaders[h.name] = h.value;
                });
                
                const responseHeaders = {};
                (res.headers || []).forEach(h => {
                    responseHeaders[h.name] = h.value;
                });
                
                // Extract type from Content-Type header
                const contentType = responseHeaders['Content-Type'] || responseHeaders['content-type'] || res.content?.mimeType || '';
                const type = getTypeFromContentType(contentType);
                
                // Extract body content from HAR format
                const requestBodyChunks = [];
                if (req.postData && req.postData.text) {
                    requestBodyChunks.push(req.postData.text);
                }
                
                const responseBodyChunks = [];
                const responseMimeType = res.content?.mimeType || '';
                // Check for encoding: "base64" OR if mimeType is image, assume base64
                const explicitEncoding = res.content?.encoding;
                const mimeType = (res.content?.mimeType || '').toLowerCase();
                const isBase64 = explicitEncoding === 'base64' || (mimeType.startsWith('image/') && mimeType !== 'image/svg+xml');
                let originalBodyContent = null;
                
                if (res.content && res.content.text) {
                    let bodyText = res.content.text;
                    // Keep original for raw display and images
                    if (isBase64) {
                        originalBodyContent = bodyText;
                        // Don't decode - keep base64 for RAW and Image views
                    }
                    responseBodyChunks.push(bodyText);
                }
                
                // Get thread info - HAR doesn't have thread info, use a default
                const threadId = 'HAR-' + (entry.pageref || '1');
                
                return {
                    id: id++,
                    uri: req.url || '',
                    method: req.method || 'GET',
                    statusCode: res.status || 0,
                    statusMessage: res.statusText || '',
                    startRequestTimestamp: startTime,
                    beginResponseTimestamp: startTime + Math.floor(time * 0.5),
                    endResponseTimestamp: startTime + time,
                    threadId: threadId,
                    requestHeaders: requestHeaders,
                    responseHeaders: responseHeaders,
                    requestBodyChunks: requestBodyChunks,
                    responseBodyChunks: responseBodyChunks,
                    responseMimeType: responseMimeType,
                    responseEncoding: isBase64 ? 'base64' : 'text',
                    responseOriginalBody: originalBodyContent,
                    type: type
                };
            });
            
            return requests;
        }
        
        function resolvePath(relativePath) {
            if (!relativePath) return '';
            
            // Get requests_data_path from the JSON config
            const dataPath = window.requestsDataPath;
            
            // Clean up the relative path
            let relPath = (relativePath || '').trim().replace(/\\/g, '/');
            
            // Remove leading ./ or .\
            while (relPath.startsWith('./')) relPath = relPath.substring(2);
            
            // If already absolute path, return it directly
            if (relPath.match(/^[A-Za-z]:/) || relPath.startsWith('/')) {
                return relPath;
            }
            
            // If no requests_data_path, return the relative path as-is (relative to current HTML file)
            if (!dataPath) {
                return relPath;
            }
            
            // Normalize base directory
            let basePath = dataPath.replace(/\\/g, '/').replace(/\/+$/, '');
            
            // Combine paths
            let combined = basePath + '/' + relPath;
            
            // Normalize: resolve . and ..
            const parts = combined.split('/');
            const normalized = [];
            for (const part of parts) {
                if (part === '..') {
                    normalized.pop();
                } else if (part !== '.' && part !== '') {
                    normalized.push(part);
                }
            }
            
            return normalized.join('/');
        }
        
        function getBodyCell(chunks, bodyPath, type, id) {
            if (chunks && chunks.length > 0) {
                return `<button class="action-btn" onclick="event.stopPropagation(); showBodyContent(${id}, '${type}')">üìÑ</button>`;
            } else if (bodyPath) {
                return `<a class="action-btn link" href="${getFileUrl(bodyPath)}" target="_blank" onclick="event.stopPropagation()">üìÑ</a>`;
            }
            return '-';
        }
        
        function showBodyContent(id, type) {
            const req = allRequests.find(r => r.id === Number(id));
            if (!req) return;
            
            const chunks = type === 'request' ? req.requestBodyChunks : req.responseBodyChunks;
            if (!chunks || chunks.length === 0) return;
            
            const content = chunks.join('\n');
            const resHeaders = req.responseHeaders || {};
            const mimeType = type === 'response' ? (req.responseMimeType || resHeaders['Content-Type'] || resHeaders['content-type'] || '') : '';
            const encoding = type === 'response' ? req.responseEncoding : 'text';
            const originalBody = type === 'response' ? req.responseOriginalBody : null;
            showBodyModal(type, content, req.id, mimeType, encoding, originalBody);
        }
        
        let currentBodyContent = '';
        let currentBodyFormat = 'raw';
        let currentBodyMimeType = '';
        let currentBodyEncoding = 'text';
        let currentBodyOriginal = null;
        
        function showBodyModal(type, content, id, mimeType = '', encoding = 'text', originalBody = null) {
            currentBodyContent = content;
            currentBodyFormat = 'raw';
            currentBodyMimeType = mimeType;
            currentBodyEncoding = encoding;
            currentBodyOriginal = originalBody;
            
            document.querySelectorAll('.format-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.format-btn[data-format="raw"]').classList.add('active');
            
            const mimeInfo = mimeType ? ` (${mimeType})` : '';
            document.getElementById('bodyModalTitle').textContent = (type === 'request' ? 'Request' : 'Response') + ' Body - ID: ' + id + mimeInfo;
            const contentEl = document.getElementById('bodyContent');
            contentEl.value = content;
            contentEl.style.display = 'block';
            contentEl.oninput = function() { this.value = content; }; // Prevent edits
            requestAnimationFrame(() => {
                contentEl.scrollTop = 0;
                contentEl.scrollLeft = 0;
            });
            updateBodySizeIndicator();
            
            document.getElementById('bodyBackdrop').classList.add('active');
            document.getElementById('bodyModal').classList.add('active');
            contentEl.focus();
            contentEl.setSelectionRange(0, 0);
        }
        
        function setBodyFormat(format) {
            currentBodyFormat = format;
            document.querySelectorAll('.format-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.format-btn[data-format="${format}"]`).classList.add('active');
            
            const contentEl = document.getElementById('bodyContent');
            
            // Reset styles from image view
            contentEl.style.display = 'block';
            contentEl.style.justifyContent = '';
            contentEl.style.alignItems = '';
            contentEl.scrollTop = 0;
            contentEl.scrollLeft = 0;
            
            // Remove image container if exists
            const imgContainer = document.getElementById('bodyImageContainer');
            if (imgContainer) imgContainer.remove();
            
            // Hide HTML container if exists
            const htmlContainer = document.getElementById('bodyHtmlContainer');
            if (htmlContainer) htmlContainer.style.display = 'none';
            
            try {
                switch (format) {
                    case 'json':
                        try {
                            const obj = JSON.parse(currentBodyContent);
                            contentEl.value = JSON.stringify(obj, null, 2);
                        } catch {
                            contentEl.value = currentBodyContent;
                        }
                        break;
                    case 'xml':
                        const xmlParser = new DOMParser();
                        const xmlDoc = xmlParser.parseFromString(currentBodyContent, 'text/xml');
                        if (xmlDoc.getElementsByTagName('parsererror').length === 0) {
                            const serializer = new XMLSerializer();
                            let xmlStr = serializer.serializeToString(xmlDoc);
                            // Pretty print XML with proper indentation
                            let formatted = '';
                            let indent = 0;
                            xmlStr = xmlStr.replace(/(>)(<)(\/*)/g, '$1\n$2$3');
                            const lines = xmlStr.split('\n');
                            for (const line of lines) {
                                let trimmed = line.trim();
                                if (!trimmed) continue;
                                // Check if this line is ONLY a closing tag (not an opening tag with content)
                                const isClosingOnly = trimmed.startsWith('</');
                                // Check if this line is ONLY an opening tag (not containing both open and close)
                                const isOpeningOnly = trimmed.startsWith('<') && !trimmed.includes('</') && !trimmed.endsWith('/>');
                                // Check if self-closing
                                const isSelfClosing = trimmed.endsWith('/>');
                                
                                if (isClosingOnly) {
                                    indent = Math.max(0, indent - 1);
                                }
                                formatted += '  '.repeat(indent) + trimmed + '\n';
                                if (isOpeningOnly && !isSelfClosing && !trimmed.startsWith('<?') && !trimmed.startsWith('<!')) {
                                    indent++;
                                }
                            }
                            contentEl.value = formatted.trim();
                        } else {
                            contentEl.value = currentBodyContent;
                        }
                        break;
                    case 'html':
                        contentEl.style.display = 'none';
                        let htmlContainer = document.getElementById('bodyHtmlContainer');
                        if (!htmlContainer) {
                            htmlContainer = document.createElement('div');
                            htmlContainer.id = 'bodyHtmlContainer';
                            htmlContainer.style.cssText = 'background:#fff;padding:15px;overflow:auto;height:calc(100vh - 160px);border-radius:6px;';
                            contentEl.insertAdjacentHTML('afterend', htmlContainer.outerHTML);
                            htmlContainer = document.getElementById('bodyHtmlContainer');
                        }
                        htmlContainer.style.display = 'block';
                        htmlContainer.innerHTML = currentBodyContent;
                        break;
                    case 'image':
                        contentEl.style.display = 'none';
                        contentEl.insertAdjacentHTML('afterend', '<div id="bodyImageContainer" style="display:flex;justify-content:center;align-items:center;height:calc(100vh - 120px);background:#1e1e1e;padding:15px;"></div>');
                        const imgContainer = document.getElementById('bodyImageContainer');
                        contentEl.style.justifyContent = 'center';
                        contentEl.style.alignItems = 'center';
                        
                        // Determine image type from mimeType or content
                        let imageType = 'image/png';
                        const mimeType = currentBodyMimeType.toLowerCase();
                        if (mimeType.includes('jpeg') || mimeType.includes('jpg')) {
                            imageType = 'image/jpeg';
                        } else if (mimeType.includes('png')) {
                            imageType = 'image/png';
                        } else if (mimeType.includes('gif')) {
                            imageType = 'image/gif';
                        } else if (mimeType.includes('webp')) {
                            imageType = 'image/webp';
                        } else if (mimeType.includes('svg')) {
                            imageType = 'image/svg+xml';
                        } else if (mimeType.includes('bmp')) {
                            imageType = 'image/bmp';
                        } else if (mimeType.includes('ico')) {
                            imageType = 'image/x-icon';
                        } else if (currentBodyContent.startsWith('\u0089PNG')) {
                            imageType = 'image/png';
                        } else if (currentBodyContent.charCodeAt(0) === 0xFF && currentBodyContent.charCodeAt(1) === 0xD8) {
                            imageType = 'image/jpeg';
                        } else if (currentBodyContent.startsWith('GIF')) {
                            imageType = 'image/gif';
                        } else if (currentBodyContent.startsWith('RIFF') && currentBodyContent.includes('WEBP')) {
                            imageType = 'image/webp';
                        }
                        
                        // SVG is text, not binary - use URL-encoded content
                        if (mimeType.includes('svg')) {
                            const encoded = encodeURIComponent(currentBodyContent);
                            imgContainer.innerHTML = `<img src="data:${imageType};utf8,${encoded}" style="max-width:100%;max-height:100%;">`;
                            break;
                        }
                        
                        // Try to use content directly if it looks like base64
                        let base64 = currentBodyContent.trim();
                        if (!/^[A-Za-z0-9+/=]+$/.test(base64) || base64.length < 100) {
                            // Try alternatives
                            if (currentBodyOriginal) {
                                base64 = currentBodyOriginal.trim();
                            }
                            if (!/^[A-Za-z0-9+/=]+$/.test(base64)) {
                                try { base64 = btoa(currentBodyContent); } 
                                catch (e) {
                                    contentEl.value = 'Failed to encode image: ' + e.message; 
                                    break;
                                }
                            }
                        }
                        imgContainer.innerHTML = `<img src="data:${imageType};base64,${base64}" style="max-width:100%;max-height:100%;">`;
                        break;
                    case 'hex':
                        let hex = '';
                        let ascii = '';
                        const len = currentBodyContent.length;
                        for (let i = 0; i < len; i++) {
                            const code = currentBodyContent.charCodeAt(i);
                            hex += code.toString(16).padStart(2, '0') + ' ';
                            ascii += (code >= 32 && code <= 126) ? currentBodyContent[i] : '.';
                            if ((i + 1) % 16 === 0) {
                                hex += '  ' + ascii + '\n';
                                ascii = '';
                            }
                        }
                        // Pad last row to align ASCII
                        if (ascii.length > 0) {
                            const padding = (16 - ascii.length) * 3;
                            hex += ' '.repeat(padding) + '  ' + ascii;
                        }
                        contentEl.value = hex || currentBodyContent;
                        break;
                    default:
                        // For raw display, use original base64 if available
                        contentEl.value = currentBodyOriginal || currentBodyContent;
                }
            } catch (e) {
                contentEl.value = currentBodyContent;
            }
        }
        
        function toggleBodyWrap() {
            const checkbox = document.getElementById('wrapToggle');
            const contentEl = document.getElementById('bodyContent');
            
            if (checkbox.checked) {
                contentEl.className = 'body-wrap';
            } else {
                contentEl.className = 'body-no-wrap';
            }
        }
        
        function updateBodySizeIndicator() {
            const content = currentBodyOriginal || currentBodyContent;
            if (!content) {
                document.getElementById('bodySizeIndicator').textContent = '--';
                return;
            }
            const bytes = new Blob([content]).size;
            let size;
            if (bytes < 1024) size = bytes + ' B';
            else if (bytes < 1024 * 1024) size = (bytes / 1024).toFixed(1) + ' KB';
            else size = (bytes / (1024 * 1024)).toFixed(1) + ' MB';
            document.getElementById('bodySizeIndicator').textContent = size;
        }
        
        function copyBodyContent() {
            const content = currentBodyOriginal || currentBodyContent;
            if (content) {
                navigator.clipboard.writeText(content).then(() => {
                    const btn = document.querySelector('button[onclick="copyBodyContent()"]');
                    if (btn) {
                        const orig = btn.textContent;
                        btn.textContent = 'Copied!';
                        setTimeout(() => btn.textContent = orig, 1500);
                    }
                });
            }
        }
        
        function setDetailBodyFormat(btn, uniqueId) {
            const container = document.getElementById('detail_' + uniqueId);
            if (container) {
                container.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
            }
            btn.classList.add('active');
            
            const raw = document.getElementById(uniqueId + '_raw').value;
            const mimeType = document.getElementById(uniqueId + '_mimetype').value;
            const encoding = document.getElementById(uniqueId + '_encoding').value;
            const original = document.getElementById(uniqueId + '_original').value;
            const contentEl = document.getElementById(uniqueId + '_content');
            
            const format = btn.dataset.format;
            contentEl.className = 'body-no-wrap';
            contentEl.style.whiteSpace = 'pre';
            contentEl.style.display = 'block';
            contentEl.style.backgroundColor = '#252525';
            contentEl.style.color = '#ccc';
            
            if (format === 'image') {
                contentEl.innerHTML = '';
                contentEl.style.display = 'flex';
                contentEl.style.justifyContent = 'center';
                contentEl.style.alignItems = 'center';
                contentEl.style.maxHeight = '400px';
                
                let base64 = raw.trim();
                const isImageMime = mimeType.toLowerCase().startsWith('image/');
                if (!/^[A-Za-z0-9+/=]+$/.test(base64) || base64.length < 100) {
                    if (original) base64 = original.trim();
                }
                
                let imageType = 'image/png';
                const mt = mimeType.toLowerCase();
                if (mt.includes('jpeg') || mt.includes('jpg')) imageType = 'image/jpeg';
                else if (mt.includes('png')) imageType = 'image/png';
                else if (mt.includes('gif')) imageType = 'image/gif';
                else if (mt.includes('webp')) imageType = 'image/webp';
                else if (mt.includes('svg')) imageType = 'image/svg+xml';
                
                // SVG is text, not binary - use URL-encoded content
                if (mt.includes('svg')) {
                    contentEl.innerHTML = `<img src="data:${imageType};utf8,${encodeURIComponent(raw)}" style="max-width:100%;max-height:100%;">`;
                } else {
                    contentEl.innerHTML = `<img src="data:${imageType};base64,${base64}" style="max-width:100%;max-height:100%;">`;
                }
            } else if (format === 'hex') {
                let hex = '', ascii = '';
                for (let i = 0; i < raw.length; i++) {
                    const code = raw.charCodeAt(i);
                    hex += code.toString(16).padStart(2, '0') + ' ';
                    ascii += (code >= 32 && code <= 126) ? raw[i] : '.';
                    if ((i + 1) % 16 === 0) {
                        hex += '  ' + ascii + '\n';
                        ascii = '';
                    }
                }
                if (ascii.length > 0) {
                    hex += ' '.repeat((16 - ascii.length) * 3) + '  ' + ascii;
                }
                contentEl.textContent = hex;
            } else if (format === 'json') {
                try {
                    contentEl.textContent = JSON.stringify(JSON.parse(raw), null, 2);
                } catch { contentEl.textContent = raw; }
            } else if (format === 'xml') {
                const parser = new DOMParser();
                const doc = parser.parseFromString(raw, 'text/xml');
                if (doc.getElementsByTagName('parsererror').length === 0) {
                    const serializer = new XMLSerializer();
                    let xmlStr = serializer.serializeToString(doc);
                    let formatted = '';
                    let indent = 0;
                    xmlStr = xmlStr.replace(/(>)(<)(\/*)/g, '$1\n$2$3');
                    const lines = xmlStr.split('\n');
                    for (const line of lines) {
                        let trimmed = line.trim();
                        if (!trimmed) continue;
                        const isClosingOnly = trimmed.startsWith('</');
                        const isOpeningOnly = trimmed.startsWith('<') && !trimmed.includes('</') && !trimmed.endsWith('/>');
                        const isSelfClosing = trimmed.endsWith('/>');
                        
                        if (isClosingOnly) {
                            indent = Math.max(0, indent - 1);
                        }
                        formatted += '  '.repeat(indent) + trimmed + '\n';
                        if (isOpeningOnly && !isSelfClosing && !trimmed.startsWith('<?') && !trimmed.startsWith('<!')) {
                            indent++;
                        }
                    }
                    contentEl.textContent = formatted.trim();
                } else { contentEl.textContent = raw; }
            } else if (format === 'html') {
                contentEl.style.backgroundColor = '#fff';
                contentEl.style.color = '#000';
                contentEl.innerHTML = raw;
            } else {
                contentEl.textContent = original || raw;
            }
        }
        
        function copyDetailBody(uniqueId) {
            const raw = document.getElementById(uniqueId + '_raw').value;
            const original = document.getElementById(uniqueId + '_original').value;
            navigator.clipboard.writeText(original || raw).then(() => {
                const btn = document.querySelector(`button[onclick="copyDetailBody('${uniqueId}')"]`);
                if (btn) {
                    const orig = btn.textContent;
                    btn.textContent = 'Copied!';
                    setTimeout(() => btn.textContent = orig, 1500);
                }
            });
        }
        
        function toggleDetailBodyWrap(uniqueId) {
            const checkbox = document.getElementById(uniqueId + '_wrap');
            const contentEl = document.getElementById(uniqueId + '_content');
            if (checkbox.checked) {
                contentEl.className = 'body-wrap';
                contentEl.style.whiteSpace = 'pre-wrap';
                contentEl.style.overflowX = 'auto';
            } else {
                contentEl.className = 'body-no-wrap';
                contentEl.style.whiteSpace = 'pre';
                contentEl.style.overflowX = 'auto';
            }
        }
        
        function closeBodyModal() {
            document.getElementById('bodyBackdrop').classList.remove('active');
            document.getElementById('bodyModal').classList.remove('active');
            // Reset wrap checkbox when closing
            const checkbox = document.getElementById('wrapToggle');
            if (checkbox) checkbox.checked = false;
            const contentEl = document.getElementById('bodyContent');
            if (contentEl) {
                contentEl.className = 'body-no-wrap';
                contentEl.style.display = 'block';
                contentEl.value = '';
            }
            // Remove image container if exists
            const imgContainer = document.getElementById('bodyImageContainer');
            if (imgContainer) imgContainer.remove();
            // Reset body metadata
            currentBodyMimeType = '';
            currentBodyEncoding = 'text';
            currentBodyOriginal = null;
        }
        
        function getDetailBodySection(req, bodyType) {
            const chunks = bodyType === 'request' ? req.requestBodyChunks : req.responseBodyChunks;
            const bodyPath = bodyType === 'request' ? req.requestBodyPath : req.responseBodyPath;
            const label = bodyType === 'request' ? 'Request' : 'Response';
            const resHeaders = bodyType === 'response' ? (req.responseHeaders || {}) : {};
            const mimeType = bodyType === 'response' ? (req.responseMimeType || resHeaders['Content-Type'] || resHeaders['content-type'] || '') : '';
            const encoding = bodyType === 'response' ? (req.responseEncoding || 'text') : 'text';
            const originalBody = bodyType === 'response' ? (req.responseOriginalBody || null) : null;
            
            if (chunks && chunks.length > 0) {
                const content = chunks.join('\n');
                const size = new Blob([originalBody || content]).size;
                const sizeStr = size < 1024 ? size + ' B' : size < 1024*1024 ? (size/1024).toFixed(1) + ' KB' : (size/(1024*1024)).toFixed(1) + ' MB';
                const uniqueId = 'detailBody_' + req.id + '_' + bodyType;
                return `<div class="detail-section collapsible collapsed" id="detail_${uniqueId}">
                    <div class="detail-section-title">
                        <div class="collapsible-title" onclick="document.getElementById('detail_${uniqueId}').classList.toggle('collapsed')">
                            <span>${label} Body (${sizeStr})</span>
                            <span class="collapse-icon">‚ñº</span>
                        </div>
                        <button class="detail-copy-btn" onclick="copyDetailBody('${uniqueId}')">Copy</button>
                    </div>
                    <div class="collapsible-content" style="background:#1e1e1e;padding:8px;border-radius:4px;margin-top:8px;">
                        <div style="display:flex;gap:4px;margin-bottom:8px;align-items:center;flex-wrap:wrap;">
                            <button class="format-btn active" data-format="raw" data-target="${uniqueId}" onclick="setDetailBodyFormat(this, '${uniqueId}')">RAW</button>
                            <button class="format-btn" data-format="json" data-target="${uniqueId}" onclick="setDetailBodyFormat(this, '${uniqueId}')">JSON</button>
                            <button class="format-btn" data-format="xml" data-target="${uniqueId}" onclick="setDetailBodyFormat(this, '${uniqueId}')">XML</button>
                            <button class="format-btn" data-format="html" data-target="${uniqueId}" onclick="setDetailBodyFormat(this, '${uniqueId}')">HTML</button>
                            <button class="format-btn" data-format="image" data-target="${uniqueId}" onclick="setDetailBodyFormat(this, '${uniqueId}')">Image</button>
                            <button class="format-btn" data-format="hex" data-target="${uniqueId}" onclick="setDetailBodyFormat(this, '${uniqueId}')">HEX</button>
                            <span style="color:#666;font-size:10px;">|</span>
                            <label style="display:flex;align-items:center;gap:4px;cursor:pointer;color:#aaa;font-size:10px;margin-left:auto;">
                                <input type="checkbox" id="${uniqueId}_wrap" onchange="toggleDetailBodyWrap('${uniqueId}')">
                                Wrap
                            </label>
                        </div>
                        <div id="${uniqueId}_content" class="body-no-wrap" style="height:250px;overflow:auto;font-size:11px;color:#ccc;white-space:pre;padding:8px;background:#252525;border-radius:4px;display:block;">${escapeHtml(content)}</div>
                    </div>
                    <textarea id="${uniqueId}_raw" style="display:none;">${escapeHtml(originalBody || content)}</textarea>
                    <input type="hidden" id="${uniqueId}_mimetype" value="${escapeHtml(mimeType)}">
                    <input type="hidden" id="${uniqueId}_encoding" value="${escapeHtml(encoding)}">
                    <input type="hidden" id="${uniqueId}_original" value="${escapeHtml(originalBody || '')}">
                </div>`;
            } else if (bodyPath) {
                return `<div class="detail-section collapsible">
                    <div class="detail-section-title">
                        <div class="collapsible-title" onclick="this.parentElement.parentElement.classList.toggle('collapsed')">
                            <span>${label} Body</span>
                            <span class="collapse-icon">‚ñº</span>
                        </div>
                        <a href="${getFileUrl(bodyPath)}" target="_blank" class="detail-copy-btn" style="color:#4fc3f7;text-decoration:none;">Open</a>
                    </div>
                    <div class="collapsible-content">
                        <a href="${getFileUrl(bodyPath)}" target="_blank" style="color:#4fc3f7;word-break:break-all;font-size:11px;">${escapeHtml(bodyPath)}</a>
                    </div>
                </div>`;
            }
            return '';
        }
        
        function getFileUrl(relativePath) {
            const resolved = resolvePath(relativePath);
            if (!resolved) return '#';
            // If it's already absolute (has drive letter or starts with /), use file:///
            if (resolved.match(/^[A-Za-z]:/) || resolved.startsWith('/')) {
                return 'file:///' + resolved;
            }
            // For relative paths, resolve against current document location
            return new URL(resolved, document.baseURI).href;
        }
        
        function getDisplayUri(uri) {
            const baseUri = document.getElementById('filterBaseUri')?.value?.trim();
            if (!baseUri || !uri) return uri;
            if (uri.startsWith(baseUri)) {
                return uri.substring(baseUri.length);
            }
            return uri;
        }
        
        function processData(data) {
            // Handle both object format {requests: [...], requests_data_path: "..."} and array format [...]
            let requests = [];
            let requestsDataPath = null;
            
            if (Array.isArray(data)) {
                requests = data;
            } else if (typeof data === 'object' && data !== null) {
                requests = data.requests || [];
                requestsDataPath = data.requests_data_path || null;
            } else {
                showError('Invalid JSON format');
                return;
            }
            
            if (!Array.isArray(requests) || requests.length === 0) {
                showError('No requests found in JSON');
                return;
            }
            
            // Store globally for use in resolvePath
            window.requestsDataPath = requestsDataPath;
            
            hideError();
            requests.sort((a, b) => a.startRequestTimestamp - b.startRequestTimestamp);
            
            const minTime = requests[0].startRequestTimestamp;
            const maxTime = Math.max(...requests.map(d => d.endResponseTimestamp || d.beginResponseTimestamp || d.startRequestTimestamp));
            const totalRange = maxTime - minTime;
            
            timeRange = { min: minTime, max: maxTime };
            
            const avgDuration = requests.reduce((sum, d) => {
                const end = d.endResponseTimestamp || d.beginResponseTimestamp || d.startRequestTimestamp;
                return sum + (end - d.startRequestTimestamp);
            }, 0) / requests.length;
            
            // Calculate additional statistics
            const durations = requests.map(d => {
                const end = d.endResponseTimestamp || d.beginResponseTimestamp || d.startRequestTimestamp;
                return end - d.startRequestTimestamp;
            });
            const maxDuration = Math.max(...durations);
            const topDelayedIndex = durations.indexOf(maxDuration);
            const topDelayed = requests[topDelayedIndex];
            
            const totalRequestTime = requests.reduce((sum, d) => {
                const respStart = d.beginResponseTimestamp || d.endResponseTimestamp || d.startRequestTimestamp;
                return sum + (respStart - d.startRequestTimestamp);
            }, 0);
            
            const totalResponseTime = requests.reduce((sum, d) => {
                if (d.endResponseTimestamp && d.beginResponseTimestamp) {
                    return sum + (d.endResponseTimestamp - d.beginResponseTimestamp);
                }
                return sum;
            }, 0);
            
            const avgRequestTime = totalRequestTime / requests.length;
            const avgResponseTime = requests.filter(d => d.endResponseTimestamp && d.beginResponseTimestamp).length > 0 
                ? totalResponseTime / requests.filter(d => d.endResponseTimestamp && d.beginResponseTimestamp).length 
                : 0;
            
            allRequests = requests.map(req => {
                const startTs = req.startRequestTimestamp;
                const dt = new Date(startTs);
                // Format: DD/MM HH:mm:ss.SSS (24h format with date)
                const day = String(dt.getDate()).padStart(2, '0');
                const month = String(dt.getMonth() + 1).padStart(2, '0');
                const hours = String(dt.getHours()).padStart(2, '0');
                const mins = String(dt.getMinutes()).padStart(2, '0');
                const secs = String(dt.getSeconds()).padStart(2, '0');
                const ms = String(dt.getMilliseconds()).padStart(3, '0');
                const fullDt = `${day}/${month} ${hours}:${mins}:${secs}.${ms}`;
                const timeOnly = `${hours}:${mins}:${secs}`;
                
                let end = req.endResponseTimestamp || req.beginResponseTimestamp;
                if (!end || end === 0) end = startTs + 10000;
                
                const duration = end - startTs;
                const requestTime = (req.beginResponseTimestamp || end) - startTs;
                const responseTime = req.endResponseTimestamp && req.beginResponseTimestamp 
                    ? req.endResponseTimestamp - req.beginResponseTimestamp 
                    : 0;
                
                const status = req.statusCode ?? '???';
                const msg = req.statusMessage || (typeof status === 'number' ? getDefaultStatusMessage(status) : 'No Message');
                const uri = req.uri || '';
                const endpoint = uri.split('?')[0].split('/').pop() || uri;
                
                // Determine status class based on HTTP status code
                let statusClass = 'status-0xx'; // default for invalid/unknown
                if (typeof status === 'number') {
                    if (status < 0 || status === 0) {
                        statusClass = 'status-0xx';
                    } else if (status >= 100 && status < 200) {
                        statusClass = 'status-1xx';
                    } else if (status >= 200 && status < 300) {
                        statusClass = 'status-2xx';
                    } else if (status >= 300 && status < 400) {
                        statusClass = 'status-3xx';
                    } else if (status >= 400 && status < 500) {
                        statusClass = 'status-4xx';
                    } else if (status >= 500 && status < 600) {
                        statusClass = 'status-5xx';
                    } else if (status >= 600) {
                        statusClass = 'status-6xx';
                    }
                }
                
                const method = req.method || 'GET';
                const methodClass = method.toLowerCase();
                
                // Extract type from response headers or use existing type from HAR conversion
                const resHeaders = req.responseHeaders || {};
                const contentType = resHeaders['Content-Type'] || resHeaders['content-type'] || req.responseMimeType || '';
                const type = req.type || getTypeFromContentType(contentType);
                
                return {
                    id: req.id,
                    startTs,
                    endTs: end,
                    duration,
                    durationHuman: formatDuration(duration),
                    requestTime,
                    requestTimeHuman: formatDuration(requestTime),
                    responseTime,
                    responseTimeHuman: formatDuration(responseTime),
                    status,
                    msg,
                    uri,
                    endpoint,
                    statusClass,
                    method,
                    methodClass,
                    fullDt,
                    timeOnly,
                    requestBodyPath: req.requestBodyPath || '',
                    responseBodyPath: req.responseBodyPath || '',
                    requestBodyChunks: req.requestBodyChunks || [],
                    responseBodyChunks: req.responseBodyChunks || [],
                    requestHeaders: req.requestHeaders || {},
                    responseHeaders: req.responseHeaders || {},
                    threadId: req.threadId || req.ThreadId || '--',
                    type: type
                };
            });
            
            filteredRequests = [...allRequests];
            
            // Count successful (2xx) and failed (4xx, 5xx) requests
            const successCount = allRequests.filter(r => r.status >= 200 && r.status < 300).length;
            const failedCount = allRequests.filter(r => r.status >= 400 || (r.status < 0)).length;
            
            document.getElementById('statsTotalRequests').textContent = allRequests.length;
            const topDelayedEl = document.getElementById('statsTopDelayed');
            topDelayedEl.textContent = `ID#${topDelayed?.id || '--'} (${formatDuration(maxDuration)})`;
            topDelayedEl.dataset.requestId = topDelayed?.id || '';
            document.getElementById('statsAvgDuration').textContent = formatDuration(avgDuration);
            document.getElementById('statsAvgRequestTime').textContent = formatDuration(avgRequestTime);
            document.getElementById('statsAvgResponseTime').textContent = formatDuration(avgResponseTime);
            document.getElementById('statsTotalRequestTime').textContent = formatDuration(totalRequestTime);
            document.getElementById('statsTotalResponseTime').textContent = formatDuration(totalResponseTime);
            document.getElementById('statsTotalTime').textContent = formatDuration(totalRange);
            document.getElementById('statsSuccessCount').textContent = successCount;
            document.getElementById('statsFailedCount').textContent = failedCount;
            document.getElementById('statsButton').style.display = 'inline-block';
            setupStatsPopupHover();

            renderTimeline();
            zoomToFit();
        }
        
        // Convert slider value (0-100) to actual timeline width using logarithmic scale
        function sliderToWidth(sliderValue) {
            // Slider 0-100 maps to 500-2M using exponential curve
            // This makes lower zoom levels less sensitive
            const minLog = Math.log(500);
            const maxLog = Math.log(2000000);
            const scale = (maxLog - minLog) / 100;
            return Math.round(Math.exp(minLog + scale * sliderValue));
        }
        
        function widthToSlider(width) {
            const minLog = Math.log(500);
            const maxLog = Math.log(2000000);
            const scale = (maxLog - minLog) / 100;
            return Math.round((Math.log(width) - minLog) / scale);
        }
        
        function getTimelineWidth() {
            const zoomSlider = document.getElementById('zoomSlider');
            if (!zoomSlider) return 20000;
            return sliderToWidth(parseInt(zoomSlider.value));
        }
        
        function handleZoomChange() {
            renderTimeline(true);
        }
        
        function zoomIn() {
            const zoomSlider = document.getElementById('zoomSlider');
            if (!zoomSlider) return;
            const current = parseInt(zoomSlider.value);
            zoomSlider.value = Math.min(100, current + 5);
            handleZoomChange();
        }
        
        function zoomOut() {
            const zoomSlider = document.getElementById('zoomSlider');
            if (!zoomSlider) return;
            const current = parseInt(zoomSlider.value);
            zoomSlider.value = Math.max(0, current - 5);
            handleZoomChange();
        }
        
        function renderTimeline(preserveScroll = false, scrollToId = null, savedScrollTop = null) {
            const zoomSlider = document.getElementById('zoomSlider');
            const prevWidth = zoomSlider ? parseInt(zoomSlider.getAttribute('data-prev-value') || 20000) : 20000;
            
            const container = document.getElementById('timeline');
            
            const timelineSection = document.querySelector('.timeline-section');
            const detailsSection = document.querySelector('.details-section');
            let firstVisibleTimestamp = null;
            let oldScrollTop = savedScrollTop || 0;
            
            if (preserveScroll && timelineSection && !scrollToId) {
                // Find the first visible cell's start timestamp
                const scrollLeft = timelineSection.scrollLeft;
                const bars = timelineSection.querySelectorAll('.timeline-bar');
                for (const bar of bars) {
                    const barLeft = bar.offsetLeft;
                    const barWidth = bar.offsetWidth;
                    // Check if bar's start is visible (within viewport)
                    if (barLeft >= scrollLeft) {
                        firstVisibleTimestamp = parseInt(bar.dataset.start);
                        break;
                    }
                    // Also check if bar is partially visible (start is before scroll but bar extends into view)
                    if (barLeft + barWidth > scrollLeft) {
                        firstVisibleTimestamp = parseInt(bar.dataset.start);
                        break;
                    }
                }
                oldScrollTop = detailsSection ? detailsSection.scrollTop : 0;
            }
            
            threadColors = {};
            
            const timelineWidth = getTimelineWidth();
            
            if (zoomSlider) {
                zoomSlider.setAttribute('data-prev-value', timelineWidth);
            }
            
            const displayValue = timelineWidth >= 1000000 ? (timelineWidth / 1000000).toFixed(1) + 'M px' : 
                                 timelineWidth >= 1000 ? (timelineWidth / 1000).toFixed(0) + 'k px' : 
                                 timelineWidth + 'px';
            document.getElementById('zoomValue').textContent = displayValue;
            
            const range = timeRange.max - timeRange.min || 1;
            
            let detailsHtml = `
                <div class="details-section">
                    <table class="timeline-table">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>ID</th>
                                <th>Thread</th>
                                <th>Timestamp</th>
                                <th>Method</th>
                                <th>Duration</th>
                                <th>Status</th>
                                <th>Type</th>
                                <th>Req</th>
                                <th>Res</th>
                                <th>Hdr</th>
                                <th>URI</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            const timelineSectionEl = document.querySelector('.timeline-section');
            const visibleWidth = timelineSectionEl ? timelineSectionEl.clientWidth : 1000;
            const effectiveTimelineWidth = Math.max(timelineWidth, visibleWidth);
            
            let timelineHtml = `
                <div class="timeline-section" id="timelineSection">
                    <div class="timeline-header" style="width: ${effectiveTimelineWidth}px;">
                        ${renderTimeHeader(range, timelineWidth)}
                    </div>
                    <div class="timeline-scroll" id="timelineScroll" style="width: ${effectiveTimelineWidth}px;">
            `;
            
            filteredRequests.forEach((req, index) => {
                const leftPx = ((req.startTs - timeRange.min) / range) * timelineWidth;
                const rightPx = ((req.endTs - timeRange.min) / range) * timelineWidth;
                const actualWidthPx = rightPx - leftPx;
                const threadColor = getThreadColor(req.threadId);
                const threadLabel = req.threadId !== '--' ? (req.threadId.length > 15 ? req.threadId.substring(0, 15) + '...' : req.threadId) : '--';
                const threadTitle = req.threadId !== '--' ? req.threadId : '';
                
                const minVisibleWidth = 4;
                const displayWidth = Math.max(actualWidthPx, minVisibleWidth);
                const isExaggerated = actualWidthPx < minVisibleWidth;
                const rowNum = index + 1;
                
                detailsHtml += `
                    <tr class="request-row"
                        data-id="${req.id}"
                        data-start="${req.startTs}"
                        data-end="${req.endTs}"
                        data-duration="${req.duration}"
                        data-uri="${escapeHtml(req.uri).replace(/"/g, '&quot;')}"
>
                        <td style="text-align: center;">${rowNum}</td>
                        <td style="font-size: 13px; font-weight: 500; cursor: pointer; color: #4fc3f7; text-decoration: underline;">${req.id}</td>
                        <td><span class="thread-badge" style="background:${threadColor};font-size:10px;padding:2px 6px;" title="${threadTitle}">${threadLabel}</span></td>
                        <td style="font-size: 12px; color: #ccc;">${req.fullDt}</td>
                        <td style="text-align: center;"><span class="endpoint-method ${req.methodClass}" style="font-size: 11px; padding: 2px 7px;">${req.method}</span></td>
                        <td class="duration-text" style="font-size: 12px;">${req.durationHuman}</td>
                        <td><span class="status-badge ${req.statusClass}" style="font-size: 12px; padding: 2px 7px;" title="${req.msg}">${req.status}</span></td>
                        <td style="text-align: center;"><span class="type-badge type-${(req.type || '').toLowerCase()}" title="${escapeHtml(req.type || '')}">${req.type || '-'}</span></td>
                        <td style="text-align: center;">${getBodyCell(req.requestBodyChunks, req.requestBodyPath, 'request', req.id)}</td>
                        <td style="text-align: center;">${getBodyCell(req.responseBodyChunks, req.responseBodyPath, 'response', req.id)}</td>
                        <td style="text-align: center;"><button class="action-btn" onclick="event.stopPropagation(); showHeaders(${req.id})">üìö</button></td>
                        <td class="endpoint-cell" style="font-size: 12px;" onmouseenter="showUriTooltipFromData(event, this)" onmouseleave="hideUriTooltip()" data-original-uri="${escapeHtml(req.uri).replace(/"/g, '&quot;')}">
                            ${escapeHtml(getDisplayUri(req.uri))}
                        </td>
                    </tr>
                `;
                
                const showContent = displayWidth > 60;
                const showBadge = displayWidth > 25;
                
                timelineHtml += `
                    <div class="timeline-column" data-id="${req.id}">
                        <div class="timeline-bar ${req.statusClass} ${isExaggerated ? 'exaggerated' : ''}" 
                             style="left: ${leftPx}px; width: ${displayWidth}px;"
                             data-id="${req.id}"
                             data-start="${req.startTs}"
                             data-end="${req.endTs}"
                             title="${req.endpoint} - ${req.durationHuman}">
                            <span class="thread-badge" style="background:${threadColor};font-size:10px;padding:2px 6px;" title="${threadTitle}">${threadLabel}</span>
                        </div>
                    </div>
                `;
            });
            
            detailsHtml += `
                        </tbody>
                    </table>
                </div>
                <div class="resizer" id="resizer"></div>
            `;
            
            timelineHtml += `
                    </div>
                </div>
            `;
            
            container.innerHTML = detailsHtml + timelineHtml;
            
            initResizer();
            syncScrollHandler();
            setupResizeHandler();
            
            // Restore measurement markers after re-render
            if (startTime !== null || endTime !== null) {
                const newTimelineScroll = document.querySelector('.timeline-scroll');
                const newWidth = getTimelineWidth();
                const range = timeRange.max - timeRange.min || 1;
                
                if (startTime !== null) {
                    const startPx = ((startTime - timeRange.min) / range) * newWidth;
                    startMarker = document.createElement('div');
                    startMarker.className = 'measure-marker start';
                    const label = document.createElement('div');
                    label.className = 'measure-marker-label start';
                    const dt = new Date(startTime);
                    const day = String(dt.getDate()).padStart(2, '0');
                    const hours = String(dt.getHours()).padStart(2, '0');
                    const mins = String(dt.getMinutes()).padStart(2, '0');
                    const secs = String(dt.getSeconds()).padStart(2, '0');
                    const ms = String(dt.getMilliseconds()).padStart(3, '0');
                    label.textContent = `${day}T${hours}:${mins}:${secs}.${ms}`;
                    startMarker.appendChild(label);
                    startMarker.style.left = startPx + 'px';
                    startMarker.style.height = '100%';
                    newTimelineScroll.appendChild(startMarker);
                }

                if (endTime !== null) {
                    const endPx = ((endTime - timeRange.min) / range) * newWidth;
                    endMarker = document.createElement('div');
                    endMarker.className = 'measure-marker end';
                    const label = document.createElement('div');
                    label.className = 'measure-marker-label end';
                    const dt = new Date(endTime);
                    const day = String(dt.getDate()).padStart(2, '0');
                    const hours = String(dt.getHours()).padStart(2, '0');
                    const mins = String(dt.getMinutes()).padStart(2, '0');
                    const secs = String(dt.getSeconds()).padStart(2, '0');
                    const ms = String(dt.getMilliseconds()).padStart(3, '0');
                    label.textContent = `${day}T${hours}:${mins}:${secs}.${ms}`;
                    endMarker.appendChild(label);
                    endMarker.style.left = endPx + 'px';
                    endMarker.style.height = '100%';
                    newTimelineScroll.appendChild(endMarker);
                }
                
                // Ensure measure panel is visible
                document.getElementById('measurePanel').classList.add('active');
            }
            
            const newTimelineSection = document.querySelector('.timeline-section');
            const newDetailsSection = document.querySelector('.details-section');
            
            if (newDetailsSection) {
                newDetailsSection.addEventListener('click', handleRowClick);
            }
            if (newTimelineSection) {
                newTimelineSection.addEventListener('click', handleTimelineBarClick);
            }
            
            if (scrollToId) {
                // Scroll to a specific request ID
                const row = document.querySelector(`.request-row[data-id="${scrollToId}"]`);
                if (row && newDetailsSection) {
                    newDetailsSection.scrollTop = row.offsetTop - 10;
                    newTimelineSection.scrollTop = newDetailsSection.scrollTop;
                }
            } else if (preserveScroll && firstVisibleTimestamp !== null) {
                const newWidth = getTimelineWidth();
                const range = timeRange.max - timeRange.min || 1;
                
                // Calculate the new scroll position so the first visible cell's start stays at the same position
                const newScrollLeft = ((firstVisibleTimestamp - timeRange.min) / range) * newWidth;
                
                if (newTimelineSection) {
                    newTimelineSection.scrollLeft = Math.max(0, newScrollLeft);
                    newTimelineSection.scrollTop = oldScrollTop;
                }
                if (newDetailsSection) {
                    newDetailsSection.scrollTop = oldScrollTop;
                }
            }
            
            document.getElementById('content').classList.add('active');
            document.getElementById('empty').style.display = 'none';
        }
        
        function renderTimeHeader(range, width) {
            let html = '';
            const timelineSection = document.querySelector('.timeline-section');
            const visibleWidth = timelineSection ? timelineSection.clientWidth : 1000;
            const effectiveWidth = Math.max(width, visibleWidth);
            
            const minTickSpacing = 120;
            const tickCount = Math.max(5, Math.floor(effectiveWidth / minTickSpacing));
            
            for (let i = 0; i <= tickCount; i++) {
                const leftPx = (i / tickCount) * effectiveWidth;
                const time = timeRange.min + (range * i / tickCount);
                const dt = new Date(time);
                
                const day = String(dt.getDate()).padStart(2, '0');
                const hours = String(dt.getHours()).padStart(2, '0');
                const mins = String(dt.getMinutes()).padStart(2, '0');
                const secs = String(dt.getSeconds()).padStart(2, '0');
                const ms = String(dt.getMilliseconds()).padStart(3, '0');
                const timeStr = `${day}T${hours}:${mins}:${secs}.${ms}`;
                
                html += `
                    <div class="timeline-header-tick" style="left: ${leftPx}px;"></div>
                    <div class="timeline-header-label" style="left: ${leftPx}px;">${timeStr}</div>
                `;
            }
            return html;
        }
        
        let cursorLine = null;
        let cursorTime = null;
        
        function syncScrollHandler() {
            const detailsSection = document.querySelector('.details-section');
            const timelineSection = document.querySelector('.timeline-section');
            const timelineScroll = document.querySelector('.timeline-scroll');
            const tableContainer = document.querySelector('.table-container');
            
            if (!cursorLine) {
                cursorLine = document.createElement('div');
                cursorLine.className = 'cursor-line';
                cursorLine.id = 'cursorLine';
                document.body.appendChild(cursorLine);
            }
            
            if (!cursorTime) {
                cursorTime = document.createElement('div');
                cursorTime.className = 'cursor-time';
                cursorTime.id = 'cursorTime';
                document.body.appendChild(cursorTime);
            }
            
            if (detailsSection && timelineSection) {
                // Only sync vertical scrolling
                detailsSection.onscroll = () => {
                    timelineSection.scrollTop = detailsSection.scrollTop;
                };
                timelineSection.onscroll = () => {
                    detailsSection.scrollTop = timelineSection.scrollTop;
                };
            }
            
            // Global shift+scroll handler for horizontal scrolling
            document.addEventListener('wheel', (e) => {
                if (e.shiftKey) {
                    const target = e.target;
                    const isInDetails = detailsSection && detailsSection.contains(target);
                    const isInTimeline = timelineSection && timelineSection.contains(target);
                    
                    if (isInDetails) {
                        // Scroll details section (table) horizontally
                        e.preventDefault();
                        if (detailsSection) detailsSection.scrollLeft += e.deltaY;
                    } else if (isInTimeline) {
                        // Scroll timeline (gantt) horizontally
                        e.preventDefault();
                        if (timelineSection) timelineSection.scrollLeft += e.deltaY;
                    } else {
                        // Default: scroll timeline
                        e.preventDefault();
                        if (timelineSection) timelineSection.scrollLeft += e.deltaY;
                    }
                }
            }, { passive: false, capture: true });
            
            if (timelineSection && cursorLine && cursorTime) {
                timelineSection.addEventListener('mousemove', (e) => {
                    const rect = timelineSection.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const scrollLeft = timelineSection.scrollLeft;
                    const adjustedX = x + scrollLeft;
                    
                    const timelineWidth = getTimelineWidth();
                    const visibleWidth = timelineSection.clientWidth;
                    const effectiveWidth = Math.max(timelineWidth, visibleWidth);
                    const range = timeRange.max - timeRange.min || 1;
                    
                    if (adjustedX >= 0 && adjustedX <= effectiveWidth) {
                        const timestamp = timeRange.min + (adjustedX / effectiveWidth) * range;
                        const dt = new Date(timestamp);
                        const day = String(dt.getDate()).padStart(2, '0');
                        const hours = String(dt.getHours()).padStart(2, '0');
                        const mins = String(dt.getMinutes()).padStart(2, '0');
                        const secs = String(dt.getSeconds()).padStart(2, '0');
                        const ms = String(dt.getMilliseconds()).padStart(3, '0');
                        const timeStr = `${day}T${hours}:${mins}:${secs}.${ms}`;

                        cursorLine.style.display = 'block';
                        cursorLine.style.left = e.clientX + 'px';
                        cursorLine.style.top = rect.top + 'px';
                        cursorLine.style.height = rect.height + 'px';
                        
                        cursorTime.style.display = 'block';
                        cursorTime.style.left = e.clientX + 'px';
                        cursorTime.style.top = (rect.top + 5) + 'px';
                        cursorTime.textContent = timeStr;
                    }
                });
                
                timelineSection.addEventListener('mouseleave', () => {
                    cursorLine.style.display = 'none';
                    cursorTime.style.display = 'none';
                });
                
                timelineSection.addEventListener('click', (e) => {
                    if (e.target.classList.contains('timeline-bar')) return;
                    
                    const rect = timelineSection.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const scrollLeft = timelineSection.scrollLeft;
                    const adjustedX = x + scrollLeft;
                    
                    const timelineWidth = getTimelineWidth();
                    const visibleWidth = timelineSection.clientWidth;
                    const effectiveWidth = Math.max(timelineWidth, visibleWidth);
                    const range = timeRange.max - timeRange.min || 1;
                    
                    if (adjustedX >= 0 && adjustedX <= effectiveWidth) {
                        const timestamp = timeRange.min + (adjustedX / effectiveWidth) * range;
                        handleTimelineClick(timestamp, adjustedX);
                    }
                });
            }
            
            document.querySelectorAll('.request-row').forEach(row => {
                row.addEventListener('mouseenter', () => {
                    const id = row.dataset.id;
                    row.classList.add('hover');
                    const col = document.querySelector(`.timeline-column[data-id="${id}"]`);
                    if (col) col.classList.add('hover');
                    const bar = document.querySelector(`.timeline-bar[data-id="${id}"]`);
                    if (bar) bar.classList.add('hover');
                });
                row.addEventListener('mouseleave', () => {
                    const id = row.dataset.id;
                    row.classList.remove('hover');
                    const col = document.querySelector(`.timeline-column[data-id="${id}"]`);
                    if (col) col.classList.remove('hover');
                    const bar = document.querySelector(`.timeline-bar[data-id="${id}"]`);
                    if (bar) bar.classList.remove('hover');
                });
            });
            
            document.querySelectorAll('.timeline-column').forEach(col => {
                col.addEventListener('mouseenter', () => {
                    const id = col.dataset.id;
                    col.classList.add('hover');
                    const row = document.querySelector(`.request-row[data-id="${id}"]`);
                    if (row) row.classList.add('hover');
                    const bar = col.querySelector('.timeline-bar');
                    if (bar) bar.classList.add('hover');
                });
                col.addEventListener('mouseleave', () => {
                    const id = col.dataset.id;
                    col.classList.remove('hover');
                    const row = document.querySelector(`.request-row[data-id="${id}"]`);
                    if (row) row.classList.remove('hover');
                    const bar = col.querySelector('.timeline-bar');
                    if (bar) bar.classList.remove('hover');
                });
            });
        }
        
        function handleTimelineClick(timestamp, xPx) {
            const timelineScroll = document.querySelector('.timeline-scroll');
            
            // Clear table row highlights (unless only one row selected)
            if (selectedRows.size !== 1) {
                selectedRows.clear();
                lastSelectedId = null;
                updateRowHighlights();
            }
            
            // If both start and end are set, clear measurement first
            if (startTime && endTime) {
                if (startMarker) {
                    startMarker.style.display = 'none';
                }
                if (endMarker) {
                    endMarker.style.display = 'none';
                }
                startTime = null;
                endTime = null;
                selectionState = null;
                document.getElementById('measurePanel').classList.remove('active');
                return;
            }
            
            if (!selectionState) {
                if (startMarker) {
                    startMarker.style.display = 'none';
                }
                if (endMarker) {
                    endMarker.style.display = 'none';
                }
                
                selectionState = 'start';
                startTime = timestamp;
                
                if (!startMarker) {
                    startMarker = document.createElement('div');
                    startMarker.className = 'measure-marker start';
                    timelineScroll.appendChild(startMarker);
                }
                
                const label = document.createElement('div');
                label.className = 'measure-marker-label start';
                label.textContent = formatTime(timestamp);
                startMarker.innerHTML = '';
                startMarker.appendChild(label);
                startMarker.style.display = 'block';
                startMarker.style.left = xPx + 'px';
                startMarker.style.height = '100%';
                
                document.getElementById('measurePanel').classList.add('active');
                document.getElementById('measureStartId').textContent = formatTime(timestamp);
                document.getElementById('measureEndId').textContent = '...';
                document.getElementById('measureTotal').textContent = '...';
                document.getElementById('measureTime').textContent = 'Select end...';
                
            } else if (selectionState === 'start') {
                selectionState = 'end';
                endTime = timestamp;
                
                if (!endMarker) {
                    endMarker = document.createElement('div');
                    endMarker.className = 'measure-marker end';
                    timelineScroll.appendChild(endMarker);
                }
                
                const label = document.createElement('div');
                label.className = 'measure-marker-label end';
                label.textContent = formatTime(timestamp);
                endMarker.innerHTML = '';
                endMarker.appendChild(label);
                endMarker.style.display = 'block';
                endMarker.style.left = xPx + 'px';
                endMarker.style.height = '100%';
                
                const [minTs, maxTs] = startTime < timestamp ? [startTime, timestamp] : [timestamp, startTime];
                
                const rows = document.querySelectorAll('.request-row');
                let firstOrdinal = null, lastOrdinal = null;
                let firstStart = null, lastEnd = null;
                let count = 0;
                
                rows.forEach((row, idx) => {
                    const rowStart = parseInt(row.dataset.start);
                    const rowEnd = parseInt(row.dataset.end);
                    if (rowEnd >= minTs && rowStart <= maxTs) {
                        count++;
                        if (firstOrdinal === null) {
                            firstOrdinal = idx + 1;
                            firstStart = rowStart;
                        }
                        lastOrdinal = idx + 1;
                        lastEnd = rowEnd;
                    }
                });
                
                const delta = Math.abs(timestamp - startTime);
                const fullDuration = lastEnd && firstStart ? lastEnd - firstStart : delta;
                
                document.getElementById('measureEndId').textContent = formatTime(timestamp);
                document.getElementById('measureTotal').textContent = firstOrdinal !== null ? `${formatDuration(fullDuration)} (${count})` : '--';
                document.getElementById('measureTime').textContent = formatDuration(delta);
                selectionState = null;
                updateSelectionButtons();
            }
        }
        
        function formatTime(timestamp) {
            const dt = new Date(timestamp);
            const day = String(dt.getDate()).padStart(2, '0');
            const hours = String(dt.getHours()).padStart(2, '0');
            const mins = String(dt.getMinutes()).padStart(2, '0');
            const secs = String(dt.getSeconds()).padStart(2, '0');
            const ms = String(dt.getMilliseconds()).padStart(3, '0');
            return `${day}T${hours}:${mins}:${secs}.${ms}`;
        }

        function updateSelectionButtons() {
            const selBtn = document.getElementById('selBtn');
            if (selBtn) {
                const hasTimeSelection = startTime && endTime;
                const hasRowSelection = selectedRows.size > 0;
                selBtn.disabled = !hasTimeSelection && !hasRowSelection;
            }
        }

        function updateTimelineHeader() {
            const timelineSection = document.querySelector('.timeline-section');
            const timelineHeader = document.querySelector('.timeline-header');
            const timelineScroll = document.querySelector('.timeline-scroll');
            if (!timelineSection || !timelineHeader || !timelineScroll) return;
            
            const timelineWidth = getTimelineWidth();
            const visibleWidth = timelineSection.clientWidth;
            const effectiveWidth = Math.max(timelineWidth, visibleWidth);
            const range = timeRange.max - timeRange.min || 1;
            
            timelineHeader.style.width = effectiveWidth + 'px';
            timelineScroll.style.width = effectiveWidth + 'px';
            timelineHeader.innerHTML = renderTimeHeader(range, timelineWidth);
        }
        
        let resizeTimeout = null;
        let resizeHandlerSetup = false;
        function setupResizeHandler() {
            if (resizeHandlerSetup) return;
            resizeHandlerSetup = true;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    updateTimelineHeader();
                }, 100);
            });
        }
        
        function initResizer() {
            const resizer = document.getElementById('resizer');
            const detailsSection = document.querySelector('.details-section');
            
            if (!resizer || !detailsSection) return;
            
            let isResizing = false;
            let lastUpdate = 0;
            
            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                resizer.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const container = document.querySelector('.table-container');
                const containerRect = container.getBoundingClientRect();
                const newWidth = e.clientX - containerRect.left;
                
                if (newWidth >= 200 && newWidth <= containerRect.width - 300) {
                    detailsSection.style.width = newWidth + 'px';
                    const now = Date.now();
                    if (now - lastUpdate > 50) {
                        lastUpdate = now;
                        updateTimelineHeader();
                    }
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    resizer.classList.remove('dragging');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    updateTimelineHeader();
                }
            });
        }
        
        function zoomToFit() {
            initResizer();
            const zoomSlider = document.getElementById('zoomSlider');
            if (!zoomSlider) return;
            
            const timelineSection = document.querySelector('.timeline-section');
            if (!timelineSection) return;
            
            const visibleWidth = timelineSection.clientWidth;
            
            let low = 0, high = 100;
            while (low < high) {
                const mid = Math.ceil((low + high) / 2);
                if (sliderToWidth(mid) <= visibleWidth) {
                    low = mid;
                } else {
                    high = mid - 1;
                }
            }
            
            zoomSlider.value = low;
            handleZoomChange();
        }
        
        function zoomToSelection() {
            let minTime = null;
            let maxTime = null;
            
            // Prefer timeline selection if available
            if (startTime && endTime) {
                minTime = Math.min(startTime, endTime);
                maxTime = Math.max(startTime, endTime);
            } else if (selectedRows.size > 0) {
                // Fall back to row selection
                const rows = document.querySelectorAll('.request-row');
                rows.forEach(row => {
                    if (selectedRows.has(row.dataset.id)) {
                        const start = parseInt(row.dataset.start);
                        const end = parseInt(row.dataset.end);
                        if (minTime === null || start < minTime) minTime = start;
                        if (maxTime === null || end > maxTime) maxTime = end;
                    }
                });
            }
            
            if (minTime === null || maxTime === null) {
                alert('Please select a time range first by clicking two points on the timeline or selecting rows');
                return;
            }
            
            const zoomSlider = document.getElementById('zoomSlider');
            if (!zoomSlider) return;
            
            const selectionRange = maxTime - minTime;
            const totalRange = timeRange.max - timeRange.min;
            const selectionRatio = selectionRange / totalRange;
            
            const timelineSection = document.querySelector('.timeline-section');
            const visibleWidth = timelineSection ? timelineSection.clientWidth - 50 : 1000;
            
            const requiredWidth = Math.max(visibleWidth / selectionRatio, 10000);
            zoomSlider.value = Math.min(100, widthToSlider(requiredWidth));
            
            handleZoomChange();
            
            setTimeout(() => {
                const newRange = timeRange.max - timeRange.min;
                const newTimelineWidth = getTimelineWidth();
                
                const scrollX = ((minTime - timeRange.min) / newRange) * newTimelineWidth - 50;
                const ts = document.querySelector('.timeline-section');
                if (ts) ts.scrollLeft = Math.max(0, scrollX);
                
                // Re-apply row selection highlights after zoom
                updateRowHighlights();
            }, 100);
        }
        
        let uriTooltip = null;
        function showUriTooltipFromData(event, element) {
            const uri = element.dataset.originalUri || element.parentElement.dataset.uri || element.dataset.uri;
            if (!uri) return;
            if (!uriTooltip) {
                uriTooltip = document.createElement('div');
                uriTooltip.className = 'uri-tooltip';
                document.body.appendChild(uriTooltip);
            }
            uriTooltip.textContent = uri;
            uriTooltip.style.display = 'block';
            uriTooltip.style.left = event.clientX + 10 + 'px';
            uriTooltip.style.top = event.clientY + 10 + 'px';
        }
        
        function showUriTooltip(event, uri) {
            if (!uriTooltip) {
                uriTooltip = document.createElement('div');
                uriTooltip.className = 'uri-tooltip';
                document.body.appendChild(uriTooltip);
            }
            uriTooltip.textContent = uri;
            uriTooltip.style.display = 'block';
            uriTooltip.style.left = event.clientX + 10 + 'px';
            uriTooltip.style.top = event.clientY + 10 + 'px';
        }
        
        function hideUriTooltip() {
            if (uriTooltip) uriTooltip.style.display = 'none';
        }
        
        function toggleDetails(event, id) {
            event.stopPropagation();
        }
        
        function showHeaders(id) {
            const req = allRequests.find(r => r.id === id);
            if (!req) return;
            
            document.getElementById('headersTitle').textContent = `Headers - Request ID ${id}`;
            
            const reqHeaders = req.requestHeaders || {};
            const resHeaders = req.responseHeaders || {};
            
            let reqHtml = '';
            if (Object.keys(reqHeaders).length === 0) {
                reqHtml = '<div style="color: #666;">No request headers</div>';
            } else {
                for (const [key, value] of Object.entries(reqHeaders)) {
                    reqHtml += `<div class="header-row"><span class="header-key">${escapeHtml(key)}:</span><span class="header-value">${escapeHtml(String(value))}</span></div>`;
                }
            }
            
            let resHtml = '';
            if (Object.keys(resHeaders).length === 0) {
                resHtml = '<div style="color: #666;">No response headers</div>';
            } else {
                for (const [key, value] of Object.entries(resHeaders)) {
                    resHtml += `<div class="header-row"><span class="header-key">${escapeHtml(key)}:</span><span class="header-value">${escapeHtml(String(value))}</span></div>`;
                }
            }
            
            document.getElementById('requestHeadersList').innerHTML = reqHtml;
            document.getElementById('responseHeadersList').innerHTML = resHtml;
            document.getElementById('headersModal').classList.add('active');
        }
        
        function closeHeadersModal(event) {
            if (!event || event.target.id === 'headersModal') {
                document.getElementById('headersModal').classList.remove('active');
            }
        }
        
        function copyHeaders(type, btn) {
            const headersList = document.getElementById(type + 'HeadersList');
            if (!headersList) return;
            
            const rows = headersList.querySelectorAll('.header-row');
            let text = '';
            rows.forEach(row => {
                const keyEl = row.querySelector('.header-key');
                const valueEl = row.querySelector('.header-value');
                if (keyEl && valueEl) {
                    // Remove trailing colon from key since we're adding it
                    let key = keyEl.textContent.replace(/:$/, '').trim();
                    const value = valueEl.textContent;
                    if (key && value !== undefined) {
                        text += key + ': ' + value + '\n';
                    }
                }
            });
            
            navigator.clipboard.writeText(text).then(() => {
                btn.textContent = '‚úì Copied';
                setTimeout(() => btn.textContent = 'Copy', 1500);
            }).catch(() => {
                btn.textContent = 'Failed';
                setTimeout(() => btn.textContent = 'Copy', 1500);
            });
        }

        function closeDetailPanel() {
            document.getElementById('detailPanel').classList.remove('active');
            document.getElementById('detailBackdrop').classList.remove('active');
        }

        function openDetailPanel(id) {
            const req = allRequests.find(r => r.id === Number(id));
            if (!req) return;
            
            const ordinalIndex = filteredRequests.findIndex(r => r.id === req.id);
            const ordinal = ordinalIndex >= 0 ? ordinalIndex + 1 : req.id;
            
            const threadId = req.threadId || req.threadName || '--';
            const threadColor = getThreadColor(threadId);
            const threadLabel = threadId !== '--' ? (threadId.length > 15 ? threadId.substring(0, 15) + '...' : threadId) : '--';
            
            const dt = new Date(req.startTs);
            const startTime = `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')} ${String(dt.getHours()).padStart(2,'0')}:${String(dt.getMinutes()).padStart(2,'0')}:${String(dt.getSeconds()).padStart(2,'0')}.${String(dt.getMilliseconds()).padStart(3,'0')}`;
            
            document.getElementById('detailOrdinal').textContent = ordinal;
            document.getElementById('detailId').textContent = req.id;
            document.getElementById('detailThreadBadge').style.background = threadColor;
            document.getElementById('detailThreadBadge').textContent = threadId;
            document.getElementById('detailTimestamp').textContent = startTime;
            document.getElementById('detailBackdrop').classList.add('active');
            
            const content = document.getElementById('detailPanelContent');

            const statusClass = req.status >= 200 && req.status < 300 ? 'status-2xx' : req.status >= 300 && req.status < 400 ? 'status-3xx' : req.status >= 400 && req.status < 500 ? 'status-4xx' : 'status-5xx';

            let html = `
                <div class="detail-section">
                    <div class="detail-row" style="flex-direction: column; gap: 4px;">
                        <span class="detail-title-row">
                            <span class="detail-method" style="font-weight: bold; color: #81c784;">${req.method}</span>
                            <button class="detail-copy-btn" onclick="copyDetail('curl', this)">Copy as cURL</button>
                        </span>
                        <a href="${escapeHtml(req.uri)}" target="_blank" class="detail-uri" style="color: #4fc3f7; word-break: break-all; font-size: 12px;">${escapeHtml(req.uri)}</a>
                    </div>
                    ${getDetailBodySection(req, 'request')}
                </div>
                <div class="detail-section">
                    <div class="detail-section-title">
                        Response
                    </div>
                    <div class="detail-row"><span class="detail-label">Status</span><span class="detail-value ${statusClass}">${req.status} ${req.msg}</span></div>
                    <div class="detail-row"><span class="detail-label">Duration</span><span class="detail-value">${req.durationHuman}</span></div>
                    <div class="detail-row"><span class="detail-label">Type</span><span class="detail-value"><span class="type-badge type-${(req.type || '').toLowerCase()}">${req.type || '-'}</span></span></div>
                    ${getDetailBodySection(req, 'response')}
                </div>
            `;

            const reqHeaders = req.requestHeaders || {};
            if (Object.keys(reqHeaders).length > 0) {
                html += `<div class="detail-section collapsible">
                    <div class="detail-section-title">
                        <div class="collapsible-title" onclick="this.parentElement.parentElement.classList.toggle('collapsed')">
                            <span>Request Headers (${Object.keys(reqHeaders).length})</span>
                            <span class="collapse-icon">‚ñº</span>
                        </div>
                        <button class="detail-copy-btn" onclick="copyDetail('reqHeaders', this)">Copy</button>
                    </div>
                    <div class="collapsible-content">
                        <div class="headers-list">`;
                for (const [key, value] of Object.entries(reqHeaders)) {
                    html += `<div class="header-row"><span class="header-key">${escapeHtml(key)}</span><span class="header-value">${escapeHtml(String(value))}</span></div>`;
                }
                html += `</div></div></div>`;
            }

            const resHeaders = req.responseHeaders || {};
            if (Object.keys(resHeaders).length > 0) {
                html += `<div class="detail-section collapsible">
                    <div class="detail-section-title">
                        <div class="collapsible-title" onclick="this.parentElement.parentElement.classList.toggle('collapsed')">
                            <span>Response Headers (${Object.keys(resHeaders).length})</span>
                            <span class="collapse-icon">‚ñº</span>
                        </div>
                        <button class="detail-copy-btn" onclick="copyDetail('resHeaders', this)">Copy</button>
                    </div>
                    <div class="collapsible-content">
                        <div class="headers-list">`;
                for (const [key, value] of Object.entries(resHeaders)) {
                    html += `<div class="header-row"><span class="header-key">${escapeHtml(key)}</span><span class="header-value">${escapeHtml(String(value))}</span></div>`;
                }
                html += `</div></div></div>`;
            }

            content.innerHTML = html;
            document.getElementById('detailPanel').classList.add('active');
        }

        function copyDetail(type, btn) {
            let text = '';
            
            if (type === 'curl') {
                // Generate curl command
                const panel = document.getElementById('detailPanel');
                const methodEl = panel.querySelector('.detail-method');
                const uriEl = panel.querySelector('.detail-uri');
                const method = methodEl?.textContent || 'GET';
                const uri = uriEl?.textContent || '';
                
                text = `curl -X ${method}`;
                
                // Add headers - find request headers section
                const sections = panel.querySelectorAll('.detail-section');
                sections.forEach(section => {
                    const title = section.querySelector('.detail-section-title');
                    if (title && title.textContent.includes('Request Headers')) {
                        const headersList = section.querySelector('.headers-list');
                        if (headersList) {
                            const rows = headersList.querySelectorAll('.header-row');
                            rows.forEach(row => {
                                const keyEl = row.querySelector('.header-key');
                                const valueEl = row.querySelector('.header-value');
                                if (keyEl && valueEl) {
                                    let key = keyEl.textContent;
                                    const value = valueEl.textContent;
                                    if (key && value) {
                                        text += ` \\\n  -H '${key}: ${value}'`;
                                    }
                                }
                            });
                        }
                    }
                });
                
                text += ` \\\n  '${uri}'`;
                
            } else if (type === 'reqHeaders' || type === 'resHeaders') {
                // Find the section that contains this button
                const section = btn.closest('.detail-section');
                const headersList = section.querySelector('.headers-list');
                if (headersList) {
                    const rows = headersList.querySelectorAll('.header-row');
                    rows.forEach(row => {
                        const keyEl = row.querySelector('.header-key');
                        const valueEl = row.querySelector('.header-value');
                        if (keyEl && valueEl) {
                            let key = keyEl.textContent;
                            const value = valueEl.textContent;
                            if (key && value !== undefined) {
                                text += key + ': ' + value + '\n';
                            }
                        }
                    });
                }
            } else if (type === 'reqBody') {
                const panel = document.getElementById('detailPanel');
                const rows = panel.querySelectorAll('.detail-row');
                rows.forEach(row => {
                    const label = row.querySelector('.detail-label')?.textContent;
                    if (label === 'File') {
                        text = row.querySelector('.detail-value')?.textContent || '';
                    }
                });
            } else if (type === 'resBody') {
                const panel = document.getElementById('detailPanel');
                const sections = panel.querySelectorAll('.detail-section');
                sections.forEach(section => {
                    const title = section.querySelector('.detail-section-title');
                    if (title && title.textContent.includes('Response Body')) {
                        const rows = section.querySelectorAll('.detail-row');
                        rows.forEach(row => {
                            const label = row.querySelector('.detail-label')?.textContent;
                            if (label === 'File') {
                                text = row.querySelector('.detail-value')?.textContent || '';
                            }
                        });
                    }
                });
            }

            navigator.clipboard.writeText(text).then(() => {
                btn.textContent = '‚úì Copied';
                setTimeout(() => btn.textContent = 'Copy', 1500);
            }).catch(() => {
                btn.textContent = 'Failed';
                setTimeout(() => btn.textContent = 'Copy', 1500);
            });
        }

        let statsPopupTimeout = null;
        let statsPopupVisible = false;

        function setupStatsPopupHover() {
            const statsButton = document.getElementById('statsButton');
            const statsPopup = document.getElementById('statsPopup');
            const statsTopDelayed = document.getElementById('statsTopDelayed');

            if (!statsButton || !statsPopup) return;

            function showStatsPopup() {
                clearTimeout(statsPopupTimeout);
                statsPopup.classList.add('active');
                statsPopupVisible = true;
            }

            function hideStatsPopup() {
                statsPopupTimeout = setTimeout(() => {
                    statsPopup.classList.remove('active');
                    statsPopupVisible = false;
                }, 200);
            }

            statsButton.addEventListener('mouseenter', showStatsPopup);
            statsButton.addEventListener('mouseleave', hideStatsPopup);
            statsPopup.addEventListener('mouseenter', showStatsPopup);
            statsPopup.addEventListener('mouseleave', hideStatsPopup);
            statsPopup.addEventListener('click', showStatsPopup);
            
            // Click on top delayed request to scroll to it
            if (statsTopDelayed) {
                statsTopDelayed.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const topDelayedId = statsTopDelayed.dataset.requestId;
                    if (topDelayedId) {
                        // Clear previous highlights including measurement highlights
                        clearMeasure();
                        document.querySelectorAll('.request-row').forEach(r => r.classList.remove('highlight', 'selected-start', 'selected-end'));
                        document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('highlight', 'selected-start', 'selected-end'));
                        document.querySelectorAll('.timeline-column').forEach(c => c.classList.remove('highlight', 'selected-start', 'selected-end'));
                        
                        // Find and scroll to the row in details section
                        const detailsSection = document.querySelector('.details-section');
                        const row = document.querySelector(`.request-row[data-id="${topDelayedId}"]`);
                        if (row && detailsSection) {
                            const rowTop = row.offsetTop;
                            const containerHeight = detailsSection.clientHeight;
                            const rowHeight = row.offsetHeight;
                            detailsSection.scrollTop = Math.max(0, rowTop - containerHeight / 2 + rowHeight / 2);
                            row.classList.add('selected-start');
                        }
                        
                        // Scroll timeline to show the bar
                        const bar = document.querySelector(`.timeline-bar[data-id="${topDelayedId}"]`);
                        const timelineSection = document.querySelector('.timeline-section');
                        if (bar && timelineSection) {
                            const barLeft = bar.offsetLeft;
                            const containerWidth = timelineSection.clientWidth;
                            const barWidth = bar.offsetWidth;
                            timelineSection.scrollLeft = Math.max(0, barLeft - containerWidth / 2 + barWidth / 2);
                            bar.classList.add('selected-start');
                            const timelineCol = document.querySelector(`.timeline-column[data-id="${topDelayedId}"]`);
                            if (timelineCol) timelineCol.classList.add('selected-start');
                        }
                    }
                });
            }
        }

        function simulateRowClick(row) {
            const id = row.dataset.id;
            const timelineCol = document.querySelector(`.timeline-column[data-id="${id}"]`);
            
            if (!selectionState) {
                selectionState = 'start';
                startBar = row;
                row.classList.add('selected-start');
                if (timelineCol) timelineCol.classList.add('selected-start');
                highlightBarById(id, 'selected-start');
                document.getElementById('measurePanel').classList.add('active');
                document.getElementById('measureStartId').textContent = 'ID ' + id;
            } else if (selectionState === 'start') {
                selectionState = 'end';
                endBar = row;
                row.classList.add('selected-end');
                if (timelineCol) timelineCol.classList.add('selected-end');
                highlightBarById(id, 'selected-end');
                document.getElementById('measureEndId').textContent = 'ID ' + id;
                
                const startTs = parseInt(startBar.dataset.start);
                const endTs = parseInt(row.dataset.end);
                const diff = Math.abs(endTs - startTs);
                
                document.getElementById('measureTotal').textContent = formatDuration(diff);
                document.getElementById('measureTime').textContent = formatDuration(diff);
                highlightBetween(startBar, row);
                updateSelectionButtons();
            } else {
                clearMeasure();
            }
        }
        
        function highlightBarById(id, className) {
            const bar = document.querySelector(`.timeline-bar[data-id="${id}"]`);
            if (bar) bar.classList.add(className);
        }
        
        function handleRowClick(event) {
            const panel = document.getElementById('detailPanel');
            if (panel.classList.contains('active') && !panel.contains(event.target)) {
                closeDetailPanel();
                event.stopPropagation();
                return;
            }
            const row = event.target.closest('.request-row');
            if (!row) return;
            
            const id = row.dataset.id;
            const clickedCell = event.target.closest('td');
            const isIdCell = clickedCell && (clickedCell.cellIndex === 0 || clickedCell.cellIndex === 1);
            
            // Ctrl+Shift+Click: add range to selection
            if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
                event.preventDefault();
                clearMeasure();
                addRangeSelection(id);
                return;
            }
            
            // Ctrl+Click: toggle selection
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault();
                clearMeasure();
                toggleRowSelection(id);
                return;
            }
            
            // Shift+Click: add to selection from last selected
            if (event.shiftKey) {
                event.preventDefault();
                clearMeasure();
                addRangeSelection(id);
                return;
            }
            
            // Regular click: select single row
            clearMeasure();
            clearAllSelections();
            selectRow(id);
            
            scrollToRequest(id);
            
            if (isIdCell) {
                openDetailPanel(id);
            }
        }
        
        let selectedRows = new Set();
        let lastSelectedId = null;
        
        function selectRow(id) {
            selectedRows.clear();
            selectedRows.add(id);
            lastSelectedId = id;
            updateRowHighlights();
            document.getElementById('measurePanel').classList.remove('active');
        }
        
        function toggleRowSelection(id) {
            if (selectedRows.has(id)) {
                selectedRows.delete(id);
            } else {
                selectedRows.add(id);
            }
            lastSelectedId = id;
            updateRowHighlights();
            updateMeasurePanelForSelection();
        }
        
        function addRangeSelection(id) {
            if (lastSelectedId === null) {
                selectRow(id);
                return;
            }
            const rows = document.querySelectorAll('.request-row');
            const ids = Array.from(rows).map(r => r.dataset.id);
            const startIdx = ids.indexOf(lastSelectedId);
            const endIdx = ids.indexOf(id);
            if (startIdx === -1 || endIdx === -1) return;
            
            const [from, to] = startIdx < endIdx ? [startIdx, endIdx] : [endIdx, startIdx];
            for (let i = from; i <= to; i++) {
                selectedRows.add(ids[i]);
            }
            lastSelectedId = id;
            updateRowHighlights();
            
            updateMeasurePanelForSelection();
        }
        
        function updateMeasurePanelForSelection() {
            if (selectedRows.size === 0) {
                document.getElementById('measurePanel').classList.remove('active');
                return;
            }
            
            const rows = Array.from(document.querySelectorAll('.request-row'));
            const selectedArray = rows.filter(r => selectedRows.has(r.dataset.id));
            
            if (selectedArray.length === 0) return;
            
            selectedArray.sort((a, b) => parseInt(a.dataset.start) - parseInt(b.dataset.start));
            
            const firstRow = selectedArray[0];
            const lastRow = selectedArray[selectedArray.length - 1];
            
            const firstStart = parseInt(firstRow.dataset.start);
            const lastEnd = parseInt(lastRow.dataset.end);
            const lastStart = parseInt(lastRow.dataset.start);
            
            const delta = lastStart - firstStart;
            const fullDuration = lastEnd - firstStart;
            
            const firstOrdinal = rows.indexOf(firstRow) + 1;
            const lastOrdinal = rows.indexOf(lastRow) + 1;
            
            document.getElementById('measurePanel').classList.add('active');
            document.getElementById('measureStartId').textContent = '#' + firstOrdinal;
            document.getElementById('measureEndId').textContent = '#' + lastOrdinal;
            document.getElementById('measureTotal').textContent = formatDuration(fullDuration) + ' (' + selectedRows.size + ')';
            document.getElementById('measureTime').textContent = formatDuration(delta);
        }
        
        function selectAllRows() {
            const rows = document.querySelectorAll('.request-row');
            rows.forEach(row => selectedRows.add(row.dataset.id));
            lastSelectedId = rows.length > 0 ? rows[rows.length - 1].dataset.id : null;
            updateRowHighlights();
            updateMeasurePanelForSelection();
        }
        
        function clearAllSelections(hidePanel = true) {
            selectedRows.clear();
            lastSelectedId = null;
            updateRowHighlights();
            if (hidePanel) {
                document.getElementById('measurePanel').classList.remove('active');
            }
        }
        
        function updateRowHighlights() {
            document.querySelectorAll('.request-row').forEach(row => {
                row.classList.remove('selected-start', 'selected-end', 'selected');
                const timelineCol = document.querySelector(`.timeline-column[data-id="${row.dataset.id}"]`);
                if (timelineCol) timelineCol.classList.remove('selected-start', 'selected-end', 'selected');
                const bar = document.querySelector(`.timeline-bar[data-id="${row.dataset.id}"]`);
                if (bar) bar.classList.remove('selected-start', 'selected-end', 'selected');
            });
            
            selectedRows.forEach(id => {
                const row = document.querySelector(`.request-row[data-id="${id}"]`);
                if (row) row.classList.add('selected');
                const timelineCol = document.querySelector(`.timeline-column[data-id="${id}"]`);
                if (timelineCol) timelineCol.classList.add('selected');
                const bar = document.querySelector(`.timeline-bar[data-id="${id}"]`);
                if (bar) bar.classList.add('selected');
            });
        }
        
        function highlightRow(id, className) {
            const row = document.querySelector(`.request-row[data-id="${id}"]`);
            if (row) row.classList.add(className);
            const timelineCol = document.querySelector(`.timeline-column[data-id="${id}"]`);
            if (timelineCol) timelineCol.classList.add(className);
            const bar = document.querySelector(`.timeline-bar[data-id="${id}"]`);
            if (bar) bar.classList.add(className);
        }
        
        function handleTimelineBarClick(event) {
            const panel = document.getElementById('detailPanel');
            if (panel.classList.contains('active') && !panel.contains(event.target)) {
                closeDetailPanel();
                event.stopPropagation();
                return;
            }
            const bar = event.target.closest('.timeline-bar');
            if (!bar) return;
            event.stopPropagation();
            
            const id = bar.dataset.id;
            const row = document.querySelector(`.request-row[data-id="${id}"]`);
            
            // Ctrl+Shift+Click: add range to selection
            if ((event.ctrlKey || event.metaKey) && event.shiftKey) {
                event.preventDefault();
                clearMeasure();
                addRangeSelection(id);
                return;
            }
            
            // Ctrl+Click: toggle selection
            if (event.ctrlKey || event.metaKey) {
                event.preventDefault();
                clearMeasure();
                toggleRowSelection(id);
                return;
            }
            
            // Shift+Click: add to selection from last selected
            if (event.shiftKey) {
                event.preventDefault();
                clearMeasure();
                addRangeSelection(id);
                return;
            }
            
            // Regular click: select single row
            clearMeasure();
            clearAllSelections();
            selectRow(id);
            
            if (row) {
                row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        function scrollToRequest(id) {
            const bar = document.querySelector(`.timeline-bar[data-id="${id}"]`);
            if (!bar) return;
            
            const timelineSection = document.querySelector('.timeline-section');
            if (!timelineSection) return;
            
            const barLeft = bar.offsetLeft;
            timelineSection.scrollLeft = Math.max(0, barLeft - 20);
        }
        
        let regexMode = false;

        function toggleRegexMode() {
            regexMode = !regexMode;
            const btn = document.getElementById('regexToggle');
            if (regexMode) {
                btn.classList.add('active');
                document.getElementById('filterText').placeholder = 'Regex pattern...';
            } else {
                btn.classList.remove('active');
                document.getElementById('filterText').placeholder = 'Search...';
            }
            applyFilter();
        }

        function clearFilters() {
            document.getElementById('filterText').value = '';
            document.getElementById('filterThread').value = '';
            document.getElementById('filterMethod').value = '';
            document.getElementById('filterStatus').value = '';
            document.getElementById('filterMinDuration').value = '';
            document.getElementById('filterMaxDuration').value = '';
            document.getElementById('filterType').value = '';
            document.getElementById('filterBaseUri').value = '';
            hideError();
            applyFilter();
            updateClearButtonVisibility();
        }
        
        function updateClearButtonVisibility() {
            const hasFilters = 
                document.getElementById('filterText').value ||
                document.getElementById('filterThread').value ||
                document.getElementById('filterMethod').value ||
                document.getElementById('filterStatus').value ||
                document.getElementById('filterMinDuration').value ||
                document.getElementById('filterMaxDuration').value ||
                document.getElementById('filterType').value ||
                document.getElementById('filterBaseUri').value;
            
            const clearBtn = document.getElementById('clearFiltersBtn');
            const separators = document.querySelectorAll('.filter-row .vertical-separator');
            
            if (clearBtn) {
                clearBtn.style.display = hasFilters ? 'inline-block' : 'none';
            }
            
            // Show/hide last separator before clear button
            if (separators.length > 0) {
                separators[separators.length - 1].style.display = hasFilters ? 'block' : 'none';
            }
        }

        function applyFilter() {
            hideError();
            
            const text = document.getElementById('filterText').value;
            const threadInput = document.getElementById('filterThread').value.trim();
            const methodInput = document.getElementById('filterMethod').value.trim().toUpperCase();
            const statusInput = document.getElementById('filterStatus').value.trim();
            const minDurationInput = document.getElementById('filterMinDuration').value;
            const maxDurationInput = document.getElementById('filterMaxDuration').value;
            const typeInput = document.getElementById('filterType').value.trim().toUpperCase();
            
            const minDuration = minDurationInput ? parseSingleDuration(minDurationInput) : null;
            const maxDuration = maxDurationInput ? parseSingleDuration(maxDurationInput) : null;
            
            if (minDurationInput && minDuration === null) {
                showFilterError('Invalid min duration format. Use formats like: 1h, 30m, 1m 30s');
                updateClearButtonVisibility();
                return;
            }
            if (maxDurationInput && maxDuration === null) {
                showFilterError('Invalid max duration format. Use formats like: 1h, 30m, 1m 30s');
                updateClearButtonVisibility();
                return;
            }
            if (minDuration !== null && maxDuration !== null && minDuration > maxDuration) {
                showFilterError('Min duration cannot be greater than max duration');
                updateClearButtonVisibility();
                return;
            }

            // Get the first visible request before filtering
            const detailsSection = document.querySelector('.details-section');
            const timelineSection = document.querySelector('.timeline-section');
            let firstVisibleId = null;
            let oldScrollTop = 0;

            if (detailsSection) {
                oldScrollTop = detailsSection.scrollTop;
                const rows = document.querySelectorAll('.request-row');
                for (const row of rows) {
                    if (row.offsetTop >= oldScrollTop) {
                        firstVisibleId = parseInt(row.dataset.id);
                        break;
                    }
                }
            }

            // Parse status codes from input
            const statusFilters = parseStatusFilter(statusInput);

            // Parse methods from input (comma-separated)
            const methodFilters = methodInput ? methodInput.split(',').map(m => m.trim()).filter(m => m) : [];

            // Parse thread IDs from input (comma-separated)
            const threadFilters = threadInput ? threadInput.split(',').map(t => t.trim()).filter(t => t) : [];
            
            // Parse type from input (comma-separated)
            const typeFilters = typeInput ? typeInput.split(',').map(t => t.trim()).filter(t => t) : [];

            // Compile regex if in regex mode
            let textRegex = null;
            if (regexMode && text) {
                try {
                    textRegex = new RegExp(text, 'i');
                } catch (e) {
                    // Invalid regex - fall back to normal text search
                    textRegex = null;
                }
            }

            filteredRequests = allRequests.filter(req => {
                // Text/URI filter (regex or normal)
                if (text) {
                    if (regexMode && textRegex) {
                        if (!textRegex.test(req.uri) && !textRegex.test(req.endpoint)) {
                            return false;
                        }
                    } else {
                        const textLower = text.toLowerCase();
                        if (!req.endpoint.toLowerCase().includes(textLower) && !req.uri.toLowerCase().includes(textLower)) {
                            return false;
                        }
                    }
                }

                // Thread filter
                if (threadFilters.length > 0) {
                    const reqThread = req.threadId.toString();
                    const matches = threadFilters.some(t => reqThread === t || reqThread.endsWith(t));
                    if (!matches) {
                        return false;
                    }
                }

                if (methodFilters.length > 0 && !methodFilters.includes(req.method.toUpperCase())) {
                    return false;
                }
                if (statusFilters.length > 0 && !matchesStatusFilter(req.status, statusFilters)) {
                    return false;
                }
                if (minDuration !== null && req.duration < minDuration) {
                    return false;
                }
                if (maxDuration !== null && req.duration > maxDuration) {
                    return false;
                }
                if (typeFilters.length > 0) {
                    const reqType = (req.type || '').toUpperCase();
                    const matches = typeFilters.some(t => reqType === t || reqType.includes(t));
                    if (!matches) {
                        return false;
                    }
                }
                return true;
            });
            
            // Find the first matching request to scroll to
            let scrollToId = null;
            if (firstVisibleId !== null) {
                const found = filteredRequests.find(r => r.id === firstVisibleId);
                if (found) {
                    scrollToId = firstVisibleId;
                }
            }
            
            renderTimeline(false, scrollToId, oldScrollTop);
            clearMeasure();
            updateClearButtonVisibility();
        }
        
        function parseStatusFilter(input) {
            if (!input) return [];
            
            const filters = [];
            const parts = input.split(',').map(s => s.trim()).filter(s => s);
            
            for (const part of parts) {
                // Check if it's a range (e.g., "200-299" but not "-1")
                const rangeMatch = part.match(/^(-?\d+)-(-?\d+)$/);
                if (rangeMatch) {
                    const min = parseInt(rangeMatch[1]);
                    const max = parseInt(rangeMatch[2]);
                    if (!isNaN(min) && !isNaN(max)) {
                        filters.push({ type: 'range', min, max });
                    }
                } else {
                    // Single code: 200, -1, 0
                    const code = parseInt(part);
                    if (!isNaN(code)) {
                        filters.push({ type: 'single', code });
                    }
                }
            }
            
            return filters;
        }
        
        function matchesStatusFilter(status, filters) {
            if (typeof status !== 'number') return false;
            
            for (const filter of filters) {
                if (filter.type === 'single' && status === filter.code) {
                    return true;
                }
                if (filter.type === 'range' && status >= filter.min && status <= filter.max) {
                    return true;
                }
            }
            return false;
        }
        
        function highlightBetween(start, end) {
            document.querySelectorAll('.request-row').forEach(r => r.classList.remove('highlight'));
            document.querySelectorAll('.timeline-column').forEach(c => c.classList.remove('highlight'));
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('highlight'));
            if (!start || !end) return;
            
            const startTime = parseInt(start.dataset.start);
            const endTime = parseInt(end.dataset.start);
            const minTime = Math.min(startTime, endTime);
            const maxTime = Math.max(startTime, endTime);
            
            document.querySelectorAll('.request-row').forEach(r => {
                const t = parseInt(r.dataset.start);
                if (t > minTime && t < maxTime) {
                    r.classList.add('highlight');
                    const col = document.querySelector(`.timeline-column[data-id="${r.dataset.id}"]`);
                    if (col) col.classList.add('highlight');
                }
            });
        }
        
        function getDefaultStatusMessage(status) {
            const defaults = {
                100: 'Continue', 101: 'Switching Protocols', 102: 'Processing', 103: 'Early Hints',
                200: 'OK', 201: 'Created', 202: 'Accepted', 203: 'Non-Authoritative Information', 204: 'No Content', 205: 'Reset Content', 206: 'Partial Content', 207: 'Multi-Status', 208: 'Already Reported', 226: 'IM Used',
                300: 'Multiple Choices', 301: 'Moved Permanently', 302: 'Found', 303: 'See Other', 304: 'Not Modified', 305: 'Use Proxy', 307: 'Temporary Redirect', 308: 'Permanent Redirect',
                400: 'Bad Request', 401: 'Unauthorized', 402: 'Payment Required', 403: 'Forbidden', 404: 'Not Found', 405: 'Method Not Allowed', 406: 'Not Acceptable', 407: 'Proxy Authentication Required', 408: 'Request Timeout', 409: 'Conflict', 410: 'Gone', 411: 'Length Required', 412: 'Precondition Failed', 413: 'Payload Too Large', 414: 'URI Too Long', 415: 'Unsupported Media Type', 416: 'Range Not Satisfiable', 417: 'Expectation Failed', 418: "I'm a teapot", 421: 'Misdirected Request', 422: 'Unprocessable Entity', 423: 'Locked', 424: 'Failed Dependency', 425: 'Too Early', 426: 'Upgrade Required', 428: 'Precondition Required', 429: 'Too Many Requests', 431: 'Request Header Fields Too Large', 451: 'Unavailable For Legal Reasons',
                500: 'Internal Server Error', 501: 'Not Implemented', 502: 'Bad Gateway', 503: 'Service Unavailable', 504: 'Gateway Timeout', 505: 'HTTP Version Not Supported', 506: 'Variant Also Negotiates', 507: 'Insufficient Storage', 508: 'Loop Detected', 510: 'Not Extended', 511: 'Network Authentication Required'
            };
            return defaults[status] || 'Unknown';
        }
        
        function formatDuration(ms) {
            if (ms < 0) return '0ms';
            ms = Math.round(ms);
            if (ms < 1000) return ms + 'ms';
            const seconds = ms / 1000;
            if (seconds < 60) return seconds.toFixed(2) + 's';
            const minutes = seconds / 60;
            if (minutes < 60) {
                const secs = Math.floor(seconds % 60);
                const mins = Math.floor(minutes);
                return mins + 'm ' + secs + 's';
            }
            const hours = minutes / 60;
            const hrs = Math.floor(hours);
            const mins = Math.floor(minutes % 60);
            return hrs + 'h ' + mins + 'm';
        }
        
        function parseDuration(str) {
            if (!str || str.trim() === '') return null;
            str = str.trim().toLowerCase();
            
            // Check for range format: 1h-2h, 30m-1h, etc.
            if (str.includes('-')) {
                const parts = str.split('-').map(s => s.trim());
                if (parts.length === 2) {
                    const minVal = parseSingleDuration(parts[0]);
                    const maxVal = parseSingleDuration(parts[1]);
                    if (minVal !== null && maxVal !== null) {
                        return { min: minVal, max: maxVal, isRange: true };
                    }
                }
                return null;
            }
            
            // Single value
            const val = parseSingleDuration(str);
            if (val !== null) {
                return { min: val, max: null, isRange: false };
            }
            
            return null;
        }
        
        function parseSingleDuration(str) {
            if (!str || str.trim() === '') return null;
            str = str.trim().toLowerCase();
            
            // If it's a plain number, treat as milliseconds
            if (/^\d+$/.test(str)) {
                return parseInt(str, 10);
            }
            
            // Parse human-readable format: 1h 30m 20s
            let totalMs = 0;
            let hasMatch = false;
            
            // Match hours, minutes, seconds
            const hoursMatch = str.match(/(\d+)\s*h/);
            const minsMatch = str.match(/(\d+)\s*m(?!s)/);
            const secsMatch = str.match(/(\d+)\s*s/);
            
            if (hoursMatch) {
                totalMs += parseInt(hoursMatch[1], 10) * 3600000;
                hasMatch = true;
            }
            if (minsMatch) {
                totalMs += parseInt(minsMatch[1], 10) * 60000;
                hasMatch = true;
            }
            if (secsMatch) {
                totalMs += parseInt(secsMatch[1], 10) * 1000;
                hasMatch = true;
            }
            
            // Also support plain number without unit (treat as ms)
            if (/^\d+$/.test(str)) {
                return parseInt(str, 10);
            }
            
            if (!hasMatch) {
                return null; // Invalid format
            }
            
            return totalMs;
        }
        
        function clearMeasure() {
            selectionState = null;
            startTime = null;
            endTime = null;
            if (startBar) startBar.classList.remove('selected-start');
            if (endBar) endBar.classList.remove('selected-end');
            startBar = null;
            endBar = null;
            document.querySelectorAll('.request-row').forEach(r => r.classList.remove('highlight', 'selected-start', 'selected-end'));
            document.querySelectorAll('.timeline-column').forEach(c => c.classList.remove('highlight', 'selected-start', 'selected-end'));
            document.querySelectorAll('.timeline-bar').forEach(b => b.classList.remove('highlight', 'selected-start', 'selected-end'));
            if (startMarker) {
                startMarker.remove();
                startMarker = null;
            }
            if (endMarker) {
                endMarker.remove();
                endMarker = null;
            }
            document.getElementById('measurePanel').classList.remove('active');
            document.getElementById('measureStartId').textContent = '--';
            document.getElementById('measureEndId').textContent = '--';
            document.getElementById('measureTotal').textContent = '--';
            document.getElementById('measureTime').textContent = '--';
            updateSelectionButtons();
        }

        function showError(msg) {
            const box = document.getElementById('errorBox');
            box.textContent = msg;
            box.style.display = 'block';
            document.getElementById('content').classList.remove('active');
            const emptyEl = document.getElementById('empty');
            emptyEl.style.display = 'flex';
            emptyEl.classList.remove('hidden');
        }
        
        function showFilterError(msg) {
            const box = document.getElementById('errorBox');
            box.textContent = msg;
            box.style.display = 'block';
        }
        
        function hideError() {
            document.getElementById('errorBox').style.display = 'none';
        }
        
        function escapeHtml(str) {
            if (!str) return '';
            return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }
        
        function downloadSampleJson() {
            const sample = [
                {
                    "id": 1,
                    "uri": "http://localhost:3000/api/users",
                    "method": "GET",
                    "statusCode": 200,
                    "statusMessage": "OK",
                    "startRequestTimestamp": 1704067200000,
                    "beginResponseTimestamp": 1704067200150,
                    "endResponseTimestamp": 1704067200200,
                    "threadId": "main",
                    "requestHeaders": {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer token123"
                    },
                    "responseHeaders": {
                        "Content-Type": "application/json",
                        "X-Request-Id": "abc123"
                    },
                    "requestBodyPath": "request_body_1.json",
                    "responseBodyPath": "response_body_1.json"
                },
                {
                    "id": 2,
                    "uri": "http://localhost:3000/api/users",
                    "method": "POST",
                    "statusCode": 201,
                    "statusMessage": "Created",
                    "startRequestTimestamp": 1704067200300,
                    "beginResponseTimestamp": 1704067200500,
                    "endResponseTimestamp": 1704067200800,
                    "threadId": "worker-1",
                    "requestHeaders": {
                        "Content-Type": "application/json"
                    },
                    "responseHeaders": {
                        "Content-Type": "application/json"
                    },
                    "requestBodyChunks": ["{\"name\": \"John Doe\", \"email\": \"john@example.com\"}"],
                    "responseBodyChunks": ["{\"id\": 2, \"name\": \"John Doe\", \"email\": \"john@example.com\", \"createdAt\": \"2024-01-01T00:00:00Z\"}"]
                },
                {
                    "id": 3,
                    "uri": "http://localhost:3000/api/products/5",
                    "method": "PUT",
                    "statusCode": 400,
                    "statusMessage": "Bad Request",
                    "startRequestTimestamp": 1704067201000,
                    "beginResponseTimestamp": 1704067201100,
                    "endResponseTimestamp": 1704067201150,
                    "threadId": "main",
                    "requestHeaders": {
                        "Content-Type": "application/json"
                    },
                    "responseHeaders": {
                        "Content-Type": "application/json",
                        "X-Error-Code": "INVALID_INPUT"
                    }
                },
                {
                    "id": 4,
                    "uri": "http://localhost:3000/api/health",
                    "method": "GET",
                    "statusCode": 500,
                    "statusMessage": "Internal Server Error",
                    "startRequestTimestamp": 1704067202000,
                    "beginResponseTimestamp": 1704067202100,
                    "endResponseTimestamp": 1704067202500,
                    "threadId": "worker-2",
                    "requestHeaders": {},
                    "responseHeaders": {
                        "Content-Type": "text/plain"
                    }
                },
                {
                    "id": 5,
                    "uri": "http://localhost:3000/api/users/1",
                    "method": "DELETE",
                    "statusCode": 204,
                    "statusMessage": "No Content",
                    "startRequestTimestamp": 1704067203000,
                    "beginResponseTimestamp": 1704067203100,
                    "endResponseTimestamp": 1704067203150,
                    "threadId": "main"
                }
            ];
            
            const blob = new Blob([JSON.stringify(sample, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sample_http_requests.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                clearMeasure();
                closeHeadersModal();
                closeBodyModal();
                clearAllSelections();
            }
            if (e.key === '+' || e.key === '=') zoomIn();
            if (e.key === '-' || e.key === '_') zoomOut();
            if ((e.ctrlKey || e.metaKey) && e.key === 'a' && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                e.preventDefault();
                selectAllRows();
            }
        });

        // Initialize button states
        updateSelectionButtons();

        // Setup drag and drop
        setupDragAndDrop();

        function setupDragAndDrop() {
            const dropZone = document.getElementById('dropZone');
            const fileInput = document.getElementById('dropZoneFileInput');

            if (!dropZone || !fileInput) return;

            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                document.body.addEventListener(eventName, preventDefaults, false);
                dropZone.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop zone when dragging over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, highlight, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, unhighlight, false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);

            // Handle file selection from the hidden input
            fileInput.addEventListener('change', handleFileSelect);

            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function highlight() {
                dropZone.classList.add('drag-over');
            }

            function unhighlight() {
                dropZone.classList.remove('drag-over');
            }

            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                if (files.length > 0) {
                    processFile(files[0]);
                }
            }

            function processFile(file) {
                if (!file.name.endsWith('.json') && !file.name.endsWith('.har')) {
                    showError('Please select a HAR or JSON file');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        // Check if it's a HAR file
                        if (data.log && data.log.entries) {
                            const converted = convertHarToRequests(data);
                            processData(converted);
                        } else {
                            processData(data);
                        }
                    } catch (err) {
                        showError('Failed to parse file: ' + err.message);
                    }
                };
                reader.onerror = function() {
                    showError('Failed to read file');
                };
                reader.readAsText(file);
            }
        }

        document.addEventListener('click', function(e) {
            const panel = document.getElementById('detailPanel');
            if (panel.classList.contains('active')) {
                if (!panel.contains(e.target) && !e.target.closest('.request-row') && !e.target.closest('.timeline-bar')) {
                    closeDetailPanel();
                }
                e.stopPropagation();
            }
        });
    </script>
</body>
</html>
